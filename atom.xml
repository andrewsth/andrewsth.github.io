<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[BetterSTH]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://bettersth.xyz/"/>
  <updated>2016-04-06T09:49:27.315Z</updated>
  <id>http://bettersth.xyz/</id>
  
  <author>
    <name><![CDATA[sth]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[HTTP权威指南 笔记四]]></title>
    <link href="http://bettersth.xyz/2016/04/06/http-the-definitive-guide-notes04/"/>
    <id>http://bettersth.xyz/2016/04/06/http-the-definitive-guide-notes04/</id>
    <published>2016-04-06T09:49:27.000Z</published>
    <updated>2016-04-06T09:49:27.315Z</updated>
    <content type="html"><![CDATA[<h1 id="u8FDE_u63A5_u7BA1_u7406"><a href="#u8FDE_u63A5_u7BA1_u7406" class="headerlink" title="连接管理"></a>连接管理</h1><h2 id="TCP_u8FDE_u63A5"><a href="#TCP_u8FDE_u63A5" class="headerlink" title="TCP连接"></a>TCP连接</h2><p><a href="http://www.joes-hardware.com:80/power-tools.html" target="_blank" rel="external">http://www.joes-hardware.com:80/power-tools.html</a><br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTCPConnection.png" alt="Web浏览器通过TCP连接与Web服务器进行交互"></p>
<a id="more"></a>
<ul>
<li>第1-3步将服务器的IP地址和端口号从URL中分离出来</li>
<li>第4步中建立到Web服务器的TCP连接</li>
<li>在第5步通过这条连接发送一条请求报文</li>
<li>在第6步读取响应</li>
<li>在第7步关闭连接</li>
</ul>
<h3 id="TCP_u53EF_u9760_u6570_u636E_u7BA1_u9053"><a href="#TCP_u53EF_u9760_u6570_u636E_u7BA1_u9053" class="headerlink" title="TCP可靠数据管道"></a>TCP可靠数据管道</h3><p>TCP为HTTP提供一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序、正确地传送出来</p>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTCPTransfer.png" alt="TCP会按序、无差错地承载HTTP数据"></p>
<h3 id="TCP_u6D41_u662F_u5206_u6BB5_u7684_u3001_u7531IP_u5206_u7EC4_u4F20_u9001"><a href="#TCP_u6D41_u662F_u5206_u6BB5_u7684_u3001_u7531IP_u5206_u7EC4_u4F20_u9001" class="headerlink" title="TCP流是分段的、由IP分组传送"></a>TCP流是分段的、由IP分组传送</h3><p>TCP的数据是通过名为IP分组（或IP数据报）的小数据块来发送的。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpAndhttps.png" alt="HTTP和HTTPS网络协议栈"></p>
<p>HTTP就是“HTTP over TCP over IP”这个“协议栈”中的最顶层。<br>其安全版本HTTPS就是在HTTP和TCP之间插入了一个（称为TLS或SSL的）密码加密层。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTcpIPTransfer.png" alt="Tcp/IP传输"></p>
<p>HTTP要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输。TCP收到数据流后，会将数据流砍成被称作段的小数据块，并将段封装在IP分组中，通过因特网进行传输。<br>每个TCP段都是由IP分组承载，从一个IP地址发送到另一个IP地址。<br>IP地址包括：</p>
<ul>
<li>一个IP分组首部（通常为20字节）</li>
<li>一个TCP段首部（通常为20字节）</li>
<li>一个TCP数据块（0个或多个字节）</li>
</ul>
<p>IP首部包含了源和目的IP地址、长度和其他一些标记。<br>TCP段的首部包含了TCP端口号、TCP控制标记，以及用于数据排序和完整性检查的一些数字值。</p>
<h3 id="u4FDD_u6301TCP_u8FDE_u63A5_u7684_u6B63_u786E_u8FD0_u884C"><a href="#u4FDD_u6301TCP_u8FDE_u63A5_u7684_u6B63_u786E_u8FD0_u884C" class="headerlink" title="保持TCP连接的正确运行"></a>保持TCP连接的正确运行</h3><p>TCP是通过端口号来保持所有这些连接的正确运行的。<br>IP地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序。<br>TCP连接是通过 4个值来识别的的：<code>&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt;</code><br>这4个值一起唯一地定义了一条连接。两条不同的TCP连接不能拥有4个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）</p>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpFourDifferentTcps.png" alt="4个不同的TCP连接"></p>
<p>图中4条连接每个端口的相关信息：</p>
<table>
<thead>
<tr>
<th style="text-align:center">连接</th>
<th style="text-align:center">源IP地址</th>
<th style="text-align:center">源端口</th>
<th style="text-align:center">目的IP地址</th>
<th style="text-align:center">目的端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">209.1.32.34</td>
<td style="text-align:center">2034</td>
<td style="text-align:center">204.62.128.58</td>
<td style="text-align:center">4133</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">209.1.32.35</td>
<td style="text-align:center">3227</td>
<td style="text-align:center">204.62.128.58</td>
<td style="text-align:center">4140</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">209.1.32.35</td>
<td style="text-align:center">3105</td>
<td style="text-align:center">207.25.71.25</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">209.1.33.89</td>
<td style="text-align:center">5100</td>
<td style="text-align:center">207.25.71.25</td>
<td style="text-align:center">80</td>
</tr>
</tbody>
</table>
<h3 id="u7528TCP_u5957_u63A5_u5B57_u7F16_u7A0B"><a href="#u7528TCP_u5957_u63A5_u5B57_u7F16_u7A0B" class="headerlink" title="用TCP套接字编程"></a>用TCP套接字编程</h3><p>操作系统提供了一些操纵其TCP连接的工具。<br>套接字API提供的一些主要接口</p>
<table>
<thead>
<tr>
<th style="text-align:left">套接字API调用</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">s = socket(<parameters>)</parameters></td>
<td style="text-align:left">创建一个新的、未命名、未关联的套接字</td>
</tr>
<tr>
<td style="text-align:left">bind(s,<local ip:port="">)</local></td>
<td style="text-align:left">向套接字赋一个本地端口号和接口</td>
</tr>
<tr>
<td style="text-align:left">connect(s,<remote ip:port="">)</remote></td>
<td style="text-align:left">创建一条连接本地套接字与远程主机及端口的连接</td>
</tr>
<tr>
<td style="text-align:left">listen(s,…)</td>
<td style="text-align:left">标识一个本地套接字，使其可以合法接受连接</td>
</tr>
<tr>
<td style="text-align:left">s2 = accept(s)</td>
<td style="text-align:left">等待某人建立一条到本地端口的连接</td>
</tr>
<tr>
<td style="text-align:left">n = read(s,buffer,n)</td>
<td style="text-align:left">尝试从套接字向缓冲区读取n个字节</td>
</tr>
<tr>
<td style="text-align:left">n = write(s,buffer,n)</td>
<td style="text-align:left">尝试从缓冲区中向套接字写入n个字节</td>
</tr>
<tr>
<td style="text-align:left">close(s)</td>
<td style="text-align:left">完全关闭TCP连接</td>
</tr>
<tr>
<td style="text-align:left">shutdown(s,<side>)</side></td>
<td style="text-align:left">只关闭TCP连接的输入或输出端</td>
</tr>
<tr>
<td style="text-align:left">getsockopt(s,…)</td>
<td style="text-align:left">读取某个内部套接字配置选项的值</td>
</tr>
<tr>
<td style="text-align:left">setsockopt(s,…)</td>
<td style="text-align:left">修改某个内部套接字配置选项的值</td>
</tr>
</tbody>
</table>
<p>套接字API允许用户创建TCP的端点数据结构，将这些端点与远程服务器的TCP端点进行连接，并对数据流进行读写。TCP API隐藏了所有底层网络协议的握手细节，以及TCP数据流与IP分组之间</p>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FTCPAPI.png" alt="通过TCP套接字接口进行通信"></p>
<h2 id="u5BF9TCP_u6027_u80FD_u7684_u8003_u8651"><a href="#u5BF9TCP_u6027_u80FD_u7684_u8003_u8651" class="headerlink" title="对TCP性能的考虑"></a>对TCP性能的考虑</h2><p>HTTP紧挨着TCP，位于其上层，所以HTTP事务的性能在很大程度上取决于底层TCP通道的性能。</p>
<h3 id="HTTP_u4E8B_u52A1_u7684_u65F6_u5EF6"><a href="#HTTP_u4E8B_u52A1_u7684_u65F6_u5EF6" class="headerlink" title="HTTP事务的时延"></a>HTTP事务的时延</h3><p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTransactionProcess.png" alt="串行HTTP事务"></p>
<p>HTTP事务的时延有以下几种原因：</p>
<ol>
<li>客户端首先需要根据URI确定Web服务器的IP地址和端口号。如果最近没有对URI中的主机名进行访问，通过DNS解析系统将URI中的主机名转换成一个IP地址可能要花费数十秒的时间。</li>
<li>接下来，客户端会向服务器发送一条TCP连接请求，并等待服务器回送一个请求接受应答。每条新的TCP连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值会快速地叠加上去。</li>
<li>一旦连接建立起来了，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器会从TCP连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间。</li>
<li>然后，Web服务器会回送HTTP响应，这也需要花费时间。</li>
</ol>
<h3 id="u6027_u80FD_u805A_u7126_u533A_u57DF"><a href="#u6027_u80FD_u805A_u7126_u533A_u57DF" class="headerlink" title="性能聚焦区域"></a>性能聚焦区域</h3><p>最常见的TCP相关时延：</p>
<ul>
<li>TCP连接建立握手</li>
<li>TCP慢启动拥塞控制</li>
<li>数据聚集的Nagle算法</li>
<li>用于捎带确认的TCP延迟确认算法</li>
<li>TIME_WAIT时延和端口耗尽</li>
</ul>
<h3 id="TCP_u8FDE_u63A5_u7684_u63E1_u624B_u65F6_u5EF6"><a href="#TCP_u8FDE_u63A5_u7684_u63E1_u624B_u65F6_u5EF6" class="headerlink" title="TCP连接的握手时延"></a>TCP连接的握手时延</h3><p>建立一条新的TCP连接时，甚至是在发送任意数据之前，TCP软件之间会交换一系列的IP分组，对连接的有关参数进行沟通。如果连接只用来传送少量数据，这些交换过程就会严重降低HTTP的性能。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.2.3pic01.png" alt="TCP连接"></p>
<p>TCP连接握手3步骤</p>
<ol>
<li>请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（通常是40-60个字节）。这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求。</li>
<li>如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受。</li>
<li>最后，客户端向服务器回送一条确认信息，通知它连接已成功建立。现在的TCP栈都允许客户端在这个确认分组中发送数据。</li>
</ol>
<p>小的HTTP事务可能会在TCP建立上花费50%，或更多的时间。</p>
<h3 id="u5EF6_u8FDF_u786E_u8BA4"><a href="#u5EF6_u8FDF_u786E_u8BA4" class="headerlink" title="延迟确认"></a>延迟确认</h3><p>TCP实现了自己的确认机制来确保数据的成功传输。<br>每个TCP段都有一个序列号和数据完整性校验和。每个段的接收都收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。<br>“延时确定”算法会在一个特定的窗口时间（通常是100~200毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。<br>但HTTP具有双峰特征的请求-应答行为降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。</p>
<h3 id="TCP_u6162_u542F_u52A8"><a href="#TCP_u6162_u542F_u52A8" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h3><p><strong>TCP慢启动（slow start)</strong>:TCP连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输速度。用于防止因特网的突然过载和拥塞。<br>TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。</p>
<h3 id="Nagle_u7B97_u6CD5_u4E0ETCP_NODELAY"><a href="#Nagle_u7B97_u6CD5_u4E0ETCP_NODELAY" class="headerlink" title="Nagle算法与TCP_NODELAY"></a>Nagle算法与TCP_NODELAY</h3><p>Nagle算法试图在发送一个分组之前，将大量TCP数据绑定在一起，以提高网络效率。<br>Nagle算法鼓励发送全尺寸的段。只有当所有其他分组都被确认之后，Nagle算法才允许发送非全尺寸的分组。<br>Nagle算法可能会引发几种HTTP性能问题：</p>
<ol>
<li>小的HTTP报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据产生时延。</li>
<li>Nagle算法与延迟确认之间的交互存在问题-Nagle算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟100~200毫秒。<br>HTTP应用程序常常会在自己的栈中设置参数TCP_NODELAY，禁用Nagle算法，提高性能。</li>
</ol>
<h3 id="TIME_WAIT_u7D2F_u79EF_u4E0E_u7AEF_u53E3_u8017_u5C3D"><a href="#TIME_WAIT_u7D2F_u79EF_u4E0E_u7AEF_u53E3_u8017_u5C3D" class="headerlink" title="TIME_WAIT累积与端口耗尽"></a>TIME_WAIT累积与端口耗尽</h3><p>当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用其期的2倍（称为2MSL，通常为2分钟）左右，以确保在这段时间内不会创建两个具有相同IP地址和端口号的连接。如果连接率过高会产生TIME_WAIT端口耗尽问题。<br>即使没有端口耗尽，也要特别小心有大量连接处于打开状态的情况，或为处于等待状态的连接分配了大量控制块的情况。</p>
<h2 id="HTTP_u8FDE_u63A5_u7684_u5904_u7406"><a href="#HTTP_u8FDE_u63A5_u7684_u5904_u7406" class="headerlink" title="HTTP连接的处理"></a>HTTP连接的处理</h2><h3 id="u5E38_u88AB_u8BEF_u89E3_u7684Connection_u9996_u90E8"><a href="#u5E38_u88AB_u8BEF_u89E3_u7684Connection_u9996_u90E8" class="headerlink" title="常被误解的Connection首部"></a>常被误解的Connection首部</h3><p>Connection首部可以承载3种不同类型的标签：</p>
<ul>
<li>HTTP首部字段名，列出了只与此连接有关的首部</li>
<li>任意标签值，用于描述此连接的非标准选项</li>
<li>值close，说明操作完成之后需关闭这条持久连接</li>
</ul>
<p>如果连接标签中包含了一个HTTP首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去。在将报文转发出去之前，必须删除Connection首部列出的所有首部字段。由于Connection首部可以防止无意中对本地首部的转发，因此将逐跳首部名放入Connection首部被称为“对首部的保护”<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.3.1pic01.png" alt="Connection首部允许发送端指定与连接有关的选项"></p>
<h3 id="u4E32_u884C_u4E8B_u52A1_u5904_u7406_u65F6_u5EF6"><a href="#u4E32_u884C_u4E8B_u52A1_u5904_u7406_u65F6_u5EF6" class="headerlink" title="串行事务处理时延"></a>串行事务处理时延</h3><p>如果只对连接进行简单的管理，TCP性能时延可能会叠加起来。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.3.1pic01.png" alt="4个事务（串行）"></p>
<p>串行加载的另一个缺点是，有些浏览器在对象加载完毕之前无法获知对象的尺寸，而且它们可能需要尺寸信息来决定将对象放在屏幕的什么位置上，所以加载了足够多的对象之前，无法在屏幕上显示任何内容。在这种情况下，可能浏览器串行装载对象的进度很正常，但用户面对的却是一个空白的屏幕，对装载的进度一无所知。</p>
<p>提高HTTP的连接性能的4种技术</p>
<ol>
<li>并行连接<br> 通过多条TCP连接发起并发的HTTP请求</li>
<li>持久连接<br> 重用TCP连接，以消除连接及关闭时延</li>
<li>管道化连接<br> 通过共享的TCP连接发起并发的HTTP请求</li>
<li>复用的连接<br> 交替传送请求和响应报文（实验阶段）</li>
</ol>
<h2 id="u5E76_u884C_u8FDE_u63A5"><a href="#u5E76_u884C_u8FDE_u63A5" class="headerlink" title="并行连接"></a>并行连接</h2><p>HTTP允许客户端打开多条连接，并行地执行多个HTTP事务<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.4.0pic01.png" alt="每个组件都包含一个独立的HTTP事务"></p>
<h3 id="u5E76_u884C_u8FDE_u63A5_u53EF_u80FD_u4F1A_u63D0_u9AD8_u9875_u9762_u7684_u52A0_u8F7D_u901F_u5EA6"><a href="#u5E76_u884C_u8FDE_u63A5_u53EF_u80FD_u4F1A_u63D0_u9AD8_u9875_u9762_u7684_u52A0_u8F7D_u901F_u5EA6" class="headerlink" title="并行连接可能会提高页面的加载速度"></a>并行连接可能会提高页面的加载速度</h3><p>包含嵌入对象的组合页面如果能（通过并行连接）克服单条连接的空载时间和带宽限制，加载速度也会有所提高。时延可以重叠起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。</p>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.4.1pic01.png" alt="4个事务（并行）"></p>
<h3 id="u5E76_u884C_u8FDE_u63A5_u4E0D_u4E00_u5B9A_u66F4_u5FEB"><a href="#u5E76_u884C_u8FDE_u63A5_u4E0D_u4E00_u5B9A_u66F4_u5FEB" class="headerlink" title="并行连接不一定更快"></a>并行连接不一定更快</h3><p>客户端的网络带宽不足时，大部分的时间可能都是用来传送数据的。这种情况下，一个连接到速度较快服务器上的HTTP事务就会很容易地耗尽所有可用的带宽。如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。<br>而且打开大量连接会消耗很多内存资源，从而引发自身的性能问题。<br>实际上浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小的值（通常是4个）。服务器可以随意关闭来自特定客户端的超量连接。</p>
<h3 id="u5E76_u884C_u8FDE_u63A5_u53EF_u80FD_u8BA9_u4EBA_u201C_u611F_u89C9_u201D_u66F4_u5FEB_u4E00_u4E9B"><a href="#u5E76_u884C_u8FDE_u63A5_u53EF_u80FD_u8BA9_u4EBA_u201C_u611F_u89C9_u201D_u66F4_u5FEB_u4E00_u4E9B" class="headerlink" title="并行连接可能让人“感觉”更快一些"></a>并行连接可能让人“感觉”更快一些</h3><p>并行连接并不总是能使页面加载得更快一些，即使实际它们并没有加快页面的传输速度，并行连接通常也会让用户<strong>觉得</strong>页面加载的更快了。</p>
<h2 id="u6301_u4E45_u8FDE_u63A5"><a href="#u6301_u4E45_u8FDE_u63A5" class="headerlink" title="持久连接"></a>持久连接</h2><p>初始化了对某服务器HTTP请求的应用程序很可能会在不久的将来对那台服务器发起更多的请求。这种性质被称为<strong>站点本地性(site locality)</strong><br>HTTP/1.1允许HTTP设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。在事务处理结束后仍然保持在打开状态的TCP连接被称为<strong>持久连接</strong><br>非持久连接会在每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。<br>重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立过程，而且已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。</p>
<h3 id="u6301_u4E45_u4EE5_u53CA_u5E76_u884C_u8FDE_u63A5"><a href="#u6301_u4E45_u4EE5_u53CA_u5E76_u884C_u8FDE_u63A5" class="headerlink" title="持久以及并行连接"></a>持久以及并行连接</h3><p>并行连接可以提高复合页面的传输速度，但并行连接的一些缺点：</p>
<ul>
<li>每个事务都会打开/关闭一条新的连接，会耗费时间和带宽</li>
<li>由于TCP慢启动特性的存在，每条新连接的性能都会有所降低</li>
<li>可打开的并行连接数量实际上是有限的</li>
</ul>
<p>持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。<br>管理持久连接要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。<br>持久连接与并行连接配合使用可能是最高效的方式。很多Web应用程序都会打开少量的并行连接，其中的每一个都是持久连接。<br>持久连接2种类型：</p>
<ol>
<li>比较老的HTTP/1.0+”keep-alive”连接</li>
<li>现代的HTTP/1.1 “persistent”连接</li>
</ol>
<h3 id="HTTP/1-0+keep-alive_u8FDE_u63A5"><a href="#HTTP/1-0+keep-alive_u8FDE_u63A5" class="headerlink" title="HTTP/1.0+keep-alive连接"></a>HTTP/1.0+keep-alive连接</h3><p>下图显示了keep-alive连接的一些性能优点，图中将在串行连接上实现4个HTTP事务的时间线与在一条持久连接上实现同样事务所需的时间线进行了比较。由于去除了进行连接和关闭连接的开销，所以时间线有所缩减。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.2pic01.png" alt="4个事务（串行与持久连接）"></p>
<h3 id="Keep-Alive_u64CD_u4F5C"><a href="#Keep-Alive_u64CD_u4F5C" class="headerlink" title="Keep-Alive操作"></a>Keep-Alive操作</h3><p>keep-alive已经不再使用了，而且在当前的HTTP/1.1规范中也没有对它的说明了。但浏览器和服务器对keep-alive握手的使用仍然相当广泛，因此，HTTP的实现者应该做好与之进行交互操作的准备。<br>实现HTTP/1.0 keep-alive连接的客户端可以通过包含Connection: Keep-Alive首部请求将一条连接保持在打开状态。<br>如果服务器愿意为下一条请求连接保持在打开状态，就在响应中包含相同的首部。如果响应中没有Connection: Keep-Alive首部，客户端就认为服务器不支持keep-alive，会在发回响应报文之后关闭连接。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.3pic01.png" alt="HTTP/1.0 keep-alive事务首部的握手过程"></p>
<h3 id="Keep-Alive_u9009_u9879"><a href="#Keep-Alive_u9009_u9879" class="headerlink" title="Keep-Alive选项"></a>Keep-Alive选项</h3><p> keep-alive首部只是请求将连接保持在活跃状态。发出keep-alive请求之后，客户端和服务器并不一定会同意进行keep-alive会话。它们可以在任意时刻关闭空闲的keep-alive连接，并可随意限制keep-alive连接所处理事务的数量。<br> 可以用Keep-Alive通用首部中指定、由逗号分隔的选项来调节keep-alive的行为。</p>
<ul>
<li>参数timeout是在Keep-Alive响应首部发送。它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值。</li>
<li>参数max是在Keep-Alive响应首部发送的。它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值。</li>
<li>Keep-Alive首部还支持任意未经处理的属性，这些属性主要用于诊断和调试。语法为name[=value]。<br>Keep-Alive首部完全是可选的，但只有在提供Connection: Keep-Alive时才能使用它。<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span>: <span class="string">Keep-Alive</span></span><br><span class="line"><span class="attribute">Keep-Alive</span>: <span class="string">max=5, timeout=120</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Keep-Alive_u8FDE_u63A5_u7684_u9650_u5236_u548C_u89C4_u5219"><a href="#Keep-Alive_u8FDE_u63A5_u7684_u9650_u5236_u548C_u89C4_u5219" class="headerlink" title="Keep-Alive连接的限制和规则"></a>Keep-Alive连接的限制和规则</h3><p>使用keep-alive连接时的一些限制：</p>
<ul>
<li>在HTTP/1.0中，keep-alive并不是默认使用的。客户端必须发送一个Connection:Keep-Alive请求首部来激活keep-alive连接。</li>
<li>Connection:Keep-Alive首部必须随所有希望保持持久连接的报文一起发送。</li>
<li>客户端探明响应中没有Connection:Keep-Alive响应首部，就可以知道服务器发出响应之后是否会关闭连接了。</li>
<li>只有在无需检测到连接的关闭即可确定实体主体部分长度的情况下，才能将连接保持在打开状态–也就是说实体的主体部分必须有正确的Content-Length，有多部件媒体类型，或者用分块传输编码的方式进行了编码。</li>
<li>代理和网关必须执行Connection首部的规则。代理或网关必须在将报文转发出去或将其高速缓存之前，删除在Connection首部中命名的所有首部字段以及Connection首部自身。</li>
<li>严格来说，不应该与无法确定是否支持Connection首部的代理服务器建立keep-alive连接，以防止出现哑代理问题。在实际应用中不是总能做到这一点的。</li>
<li>从技术上来讲，应该忽略所有来自HTTP/1.0设备的Connection首部字段（包括Connection:Keep-Alive),因为它们可能是由比较老的代理服务器误转发的。</li>
<li>除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之前连接就关闭了，客户端就一定要做好重试请求的准备。</li>
</ul>
<h3 id="Keep-Alive_u548C_u54D1_u4EE3_u7406"><a href="#Keep-Alive_u548C_u54D1_u4EE3_u7406" class="headerlink" title="Keep-Alive和哑代理"></a>Keep-Alive和哑代理</h3><h4 id="Connection_u9996_u90E8_u548C_u76F2_u4E2D_u7EE7"><a href="#Connection_u9996_u90E8_u548C_u76F2_u4E2D_u7EE7" class="headerlink" title="Connection首部和盲中继"></a>Connection首部和盲中继</h4><p> <strong>盲中继</strong>它们只是将字节从一个连接转发到另一个连接中去，不对Connection首部进行特殊的处理。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.6pic01.png" alt="keep-alive无法与不支持Connection首部的代理进行互操作"></p>
<ol>
<li>Web客户端向代理发送了一条报文，其中包含了Connection:Keep-Alive首部，如果可能的话请求建立一条keep-alive连接。客户端等待响应，以确定对方是否认可它对keep-alive信道的请求。</li>
<li>哑代理收到了这条HTTP请求，但它并不理解Connection首部（只是将其作为一个扩展首部对待）。代理不知道keep-alive是什么意思，因此只是沿着转发链路将报文一字不漏地发送给服务器。但Connection首部是个逐跳首部，只适用于单条传输链路，不应该沿着传输链路向下传输。</li>
<li>经过中继HTTP请求抵达了Web服务器。当服务器收到经过代理转发的Connection:Keep-Alive首部时，会误以为代理（对服务器来说，这个代理看起来就和所有其他客户端一样）希望进行keep-alive对话！对Web服务器来说这没什么问题–它同意进行keep-alive对话，并回送了一个Connection:Keep-Alive响应首部。所以，此时服务器认为它在与代理进行keep-alive对话，会遵循keep-alive的规则。但代理却对keep-alive一无所知。</li>
<li>哑代理将Web服务器的响应报文回送给客户端，并将来自Web服务器的Connection:Keep-Alive首部一起传送过去。客户端看到这个首部，就会认为代理同意进行keep-alive对话。所以此时客户端和服务器都认为它们在进行keep-alive对话，但与它们进行对话的代理却对keep-alive一无所知。</li>
<li>由于代理对keep-alive一无所知，所以会将收到的所有数据都回送给客户端，然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了，所以不会去关闭连接。这样代理就会挂在那里等待连接的关闭。</li>
<li>客户端在收到回送的响应报文时，会立即转向下一条请求，在keep-alive连接上向代理发送另一条请求。而代理并不认为同一条连接上会有其他请求到来，请求被忽略，浏览器就在这里转圈，不会有任何进展了。</li>
<li>这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接超时，并将其关闭为止。</li>
</ol>
<h4 id="u4EE3_u7406_u548C_u9010_u8DF3_u9996_u90E8"><a href="#u4EE3_u7406_u548C_u9010_u8DF3_u9996_u90E8" class="headerlink" title="代理和逐跳首部"></a>代理和逐跳首部</h4><p>为避免此类代理通信问题的发生，现代的代理都绝不能转发Connection首部和所有名字出现在Connection值中的首部。因此，如果一个代理收到了一个Connection:Keep-Alive首部，是不应该转发Connection首部，或所有名为Keep-Alive首部的。<br>还有几个不能作为Connection首部值列出，也不能被代理转发或作为缓存响应使用的首部：Proxy-Authenticate, Proxy-Connection, Transfer-Encoding和Upgrade。</p>
<h3 id="u63D2_u5165Proxy-Connection"><a href="#u63D2_u5165Proxy-Connection" class="headerlink" title="插入Proxy-Connection"></a>插入Proxy-Connection</h3><p>使用Porxy-Connection来解决盲中继问题：<br>在客户端和服务器之间只有一个代理时可以用这种方案来解决问题，如果在哑代理的任意一侧还有一个聪明的代理，这个问题就会再次露头了。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.7pic01.png" alt="Proxy-Connection首部修正了单个盲中继带来的问题" title="Proxy-Connection首部修正了单个盲中继带来的问题"></p>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.7pic02.png" alt="对有多层次代理的情况，Proxy-Connection仍然无法解决问题" title="对有多层次代理的情况，Proxy-Connection仍然无法解决问题"></p>
<h3 id="HTTP/1-1_u6301_u4E45_u8FDE_u63A5"><a href="#HTTP/1-1_u6301_u4E45_u8FDE_u63A5" class="headerlink" title="HTTP/1.1持久连接"></a>HTTP/1.1持久连接</h3><p>HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为<strong>持久连接(persistent connection)</strong>的改进型设计取代了它。持久连接的目的与keep-alive连接的目的相同，但工作机制更优些。<br>HTTP/1.1持久连接在默认情况下是激活的。除非特别指明，否则HTTP/1.1假定所有连接都是持久的。要在事务处理结束之后将连接关闭，HTTP/1.1应用程序必须向报文中显式地添加一个Connection:close首部。<br>HTTP/1.1客户端假定在收到响应后，除非响应中包含了Connection:close首部，不然HTTP/1.1连接就仍维持在打开状态。但是客户端和服务器仍然可以随时关闭空闲的连接。不发送Connection:close并不意味着服务器承诺永远将连接保持在打开状态。</p>
<h3 id="u6301_u4E45_u8FDE_u63A5_u7684_u9650_u5236__u548C_u89C4_u5219"><a href="#u6301_u4E45_u8FDE_u63A5_u7684_u9650_u5236__u548C_u89C4_u5219" class="headerlink" title="持久连接的限制 和规则"></a>持久连接的限制 和规则</h3><p>在持久连接的使用中有以下限制：</p>
<ul>
<li>发送了Connection:close请求首部之后，客户端就无法在那条连接上发送更多的请求了。</li>
<li>如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个Connection:close请求首部。</li>
<li>只有当连接上所有的报文都有正确的、自定义报文长度时–也就是说，实体主体部分的长度赵向阳和相应的Content-Length一致，或者是用分块传输编码方式编码的–连接才能持久保持。</li>
<li>HTTP/1.1的代理必须能够分别管理与客户端和服务器的持久连接–每个持久连接都只适用于一跳传输。</li>
<li>（由于较老的代理会转发Connection首部，所以）HTTP/1.1的代理服务器不应该与HTTP/1.0客户端建立持久连接，除非它们了解客户端的处理能力。</li>
<li>尽管服务器不应该试图在传输报文的过程中关闭连接，而且在关闭连接之前至少应该响应一条请求，但不管Connection首部取了什么值，HTTP/1.1设备都可以在任意时刻关闭连接。</li>
<li>HTTP/1.1应用程序必须能够从异步的关闭中恢复出来。只要不存在可能会累积起来的副作用，客户端都应该重试这条请求。</li>
<li>除非重复发起请求会产生副作用，否则如果在客户端收到整条响应之前连接关闭了，客户端就必须要重新发起请求</li>
<li>一个用户客户端对任何服务器或代理最多只能维持两条持久连接，以防服务器过载。代理可能需要更多到服务器的连接来支持并发用户的通信。所以，如果有N个用户试图访问服务器的话，代理最多要维持2N条到任意服务器或父代理的连接。</li>
</ul>
<h3 id="u7BA1_u9053_u5316_u8FDE_u63A5"><a href="#u7BA1_u9053_u5316_u8FDE_u63A5" class="headerlink" title="管道化连接"></a>管道化连接</h3><p>HTTP/1.1允许在持久连接上可选地使用<strong>请求管道</strong>。这是在keep-alive连接上的进一步性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高延时网络条件下，这样做可以降低网络的环回时间，提高性能。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.6.0pic01.png" alt="4个事务（管道化连接）"><br>管道化连接的几条限制：</p>
<ul>
<li>如果HTTP客户端无法确认连接是持久的，就不应该使用管道。</li>
<li>必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。</li>
<li>HTTP客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接，并立即发出了10条请求，服务器可能在只处理了，比方说，5条请求之后关闭连接。剩下的5条请求会失败，客户端必须能够应对这些过早关闭连接的情况，重新发出这些请求。</li>
<li>HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）。总之，出错的时候 ，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法完全地重试POST这样的非幂等请求，所以出错时，就存在某些方法永远不会被执行的风险。</li>
</ul>
<h2 id="u5173_u95ED_u8FDE_u63A5_u7684_u5965_u79D8"><a href="#u5173_u95ED_u8FDE_u63A5_u7684_u5965_u79D8" class="headerlink" title="关闭连接的奥秘"></a>关闭连接的奥秘</h2><h3 id="u201C_u4EFB_u610F_u201D_u89E3_u9664_u8FDE_u63A5"><a href="#u201C_u4EFB_u610F_u201D_u89E3_u9664_u8FDE_u63A5" class="headerlink" title="“任意”解除连接"></a>“任意”解除连接</h3><p>所有HTTP客户端、服务器或代理都可以在任意时刻关闭一条TCP传输连接。通常会在一条报文结束时关闭连接，但出错的时候，也可能在首部行的中间，或其他奇怪的地方关闭连接。<br>对管道化持久连接来说，这种情形是很常见的。HTTP应用程序可以在经过任意一段时间之后，关闭持久连接。比如，在持久连接空闲一段时间之后，服务器可能会决定将其关闭。<br>服务器永远都无法确定在它关闭“空闲”连接的那一刻，在线路那一头的客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现连接错误。</p>
<h3 id="Content-Length_u53CA_u622A_u5C3E_u64CD_u4F5C"><a href="#Content-Length_u53CA_u622A_u5C3E_u64CD_u4F5C" class="headerlink" title="Content-Length及截尾操作"></a>Content-Length及截尾操作</h3><p>每条HTTP响应都应该有精确的Content-Length首部，用以描述响应主体的尺寸。一些老的HTTP服务器会省略Content-Length首部，或者包含错误的长度指示，这样就要依赖服务器发出的连接关闭来说明数据的真实末尾。<br>客户端或代理收到一条随连接关闭而结束的HTTP响应，且实际传输的实体长度与Content-Length并不匹配（或没有Content-Length）时，接收端就应该质疑长度的正确性。<br>如果接收端是个缓存代理，接收端就不应该缓存这条响应（以降低今后将潜在的错误报文混合起来的可能）。代理应该将有问题的报文原封不动地转发出去，而不应该试图去“校正”Content-Length，以维护语义的透明性。</p>
<h3 id="u8FDE_u63A5_u5173_u95ED_u5BB9_u9650_u3001_u91CD_u8BD5_u4EE5_u53CA_u5E42_u7B49_u6027"><a href="#u8FDE_u63A5_u5173_u95ED_u5BB9_u9650_u3001_u91CD_u8BD5_u4EE5_u53CA_u5E42_u7B49_u6027" class="headerlink" title="连接关闭容限、重试以及幂等性"></a>连接关闭容限、重试以及幂等性</h3><p>即使在非错误情况下，连接也可以在任意时刻关闭。HTTP应用程序要做好正确处理非预期关闭的准备。<br>如果一个事务，不管是执行一次还是很多次，得到的结果都相同，这个事务就是<strong>幂等</strong>的。实现者们可以认为GET,HEAD,PUT,DELETE,TRACE,OPTIONS方法都共享这一特性。客户端不应该以管道化方式传送非幂等请求（比如POST）。否则，传输连接的过早终止就会造成一些不确定的后果。要发送一条非幂等请求，就需要等待来自前一条请求的的响应状态。<br>用户Agent代理可能会让操作员来选择是否对请求进行重试，但一定不能自动重试非幂等方法或序列。</p>
<h3 id="u6B63_u5E38_u5173_u95ED_u8FDE_u63A5"><a href="#u6B63_u5E38_u5173_u95ED_u8FDE_u63A5" class="headerlink" title="正常关闭连接"></a>正常关闭连接</h3><p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.7.4pic01.png" alt="TCP连接是双向的"><br>TCP连接是双向的。</p>
<ol>
<li>完全关闭与半关闭<br> 应用程序可以关闭TCP输入和输出信道中的任意一个，或者将两个都关闭了。<br> <strong>完全关闭</strong>：套接字调用close()会将TCP连接的输入和输出信道都关闭了。<br> <strong>半关闭</strong>：套接字调用shutdown()单独关闭输入或输出信道。<br> <img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.7.4pic02.png" alt="完全关闭和半关闭"></li>
<li>TCP关闭及重置错误<br> 简单的HTTP应用程序可以只使用完全关闭，但当应用程序开始与很多其他类型的HTTP客户端、服务器和代理进行对话且开始使用管道化持久连接时，使用半关闭来防止对等实体收到非预期的写入错误就变得很重要了。<br> 关闭连接的输出信道总是很安全的。连接另一端的对等实体会在从缓冲区中读出所有数据之后收到一条通知，说明流结束了，这样它就知道你将连接关闭了。<br> 关闭连接的输入信道比较危险，除非你知道另一端不打算再发送其他数据了。如果另一端向你已关闭的输入信道发送数据，操作系统就会向另一端的机器回送一条TCP“连接被对端重置”的报文，大部分系统都会将这种错误作为很严重的错误来处理，删除对端还未读取的所有缓存数据。<br> <img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.7.4pic03.png" alt="将数据传送到已关闭连接时会产生“连接被对端重置”错误"></li>
<li>正常关闭<br> HTTP规范建议，当客户端或服务器突然要关闭一条连接时，应该“正常地关闭传输连接”。<br> 实现正常关闭的应用程序首先应该关闭它们的输出信道，然后等待连接另一端的对等实体关闭它的输出信道，当两端都告诉对方它们不会再发送任何数据（比如关闭输出信道）之后，连接就会被完全关闭，而不会有重置的危险。<br> 无法确保对等实体会实现半关闭，或对其进行检查。因此想要正常关闭连接的应用程序应该先半关闭其输出信道，然后周期性地检查其输入信道的状态（查找数据，或流的末尾）。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接，以节省资源。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u8FDE_u63A5_u7BA1_u7406"><a href="#u8FDE_u63A5_u7BA1_u7406" class="headerlink" title="连接管理"></a>连接管理</h1><h2 id="TCP_u8FDE_u63A5"><a href="#TCP_u8FDE_u63A5" class="headerlink" title="TCP连接"></a>TCP连接</h2><p><a href="http://www.joes-hardware.com:80/power-tools.html">http://www.joes-hardware.com:80/power-tools.html</a><br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTCPConnection.png" alt="Web浏览器通过TCP连接与Web服务器进行交互"></p>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://bettersth.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP权威指南 笔记三]]></title>
    <link href="http://bettersth.xyz/2016/04/05/http-the-definitive-guide-notes03/"/>
    <id>http://bettersth.xyz/2016/04/05/http-the-definitive-guide-notes03/</id>
    <published>2016-04-05T03:25:42.000Z</published>
    <updated>2016-04-05T03:25:42.368Z</updated>
    <content type="html"><![CDATA[<h1 id="HTTP__u62A5_u6587"><a href="#HTTP__u62A5_u6587" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h1><h2 id="u62A5_u6587_u6D41"><a href="#u62A5_u6587_u6D41" class="headerlink" title="报文流"></a>报文流</h2><p>HTTP报文是在HTTP应用程序之间发送的数据块</p>
<h3 id="u62A5_u6587_u6D41_u5165_u6E90_u7AEF_u670D_u52A1_u5668"><a href="#u62A5_u6587_u6D41_u5165_u6E90_u7AEF_u670D_u52A1_u5668" class="headerlink" title="报文流入源端服务器"></a>报文流入源端服务器</h3><p>HTTP使用术语<strong>流入(inbound)</strong>和<strong>流出(outbound)</strong>来描述<strong>事务处理(transaction)</strong><br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpTransaction.png" alt="报文流入源端服务器并流回到客户端"></p>
<a id="more"></a>
<h3 id="u62A5_u6587_u5411_u4E0B_u6E38_u6D41_u52A8"><a href="#u62A5_u6587_u5411_u4E0B_u6E38_u6D41_u52A8" class="headerlink" title="报文向下游流动"></a>报文向下游流动</h3><p>所有报文都会向<strong>下游(downstream)</strong>流动<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpUpStreamDownStreamConcept.png" alt="报文向下游流动"></p>
<h2 id="u62A5_u6587_u7684_u7EC4_u6210_u90E8_u5206"><a href="#u62A5_u6587_u7684_u7EC4_u6210_u90E8_u5206" class="headerlink" title="报文的组成部分"></a>报文的组成部分</h2><ul>
<li>对报文描述的<strong>起始行(start line)</strong></li>
<li>包含属性的<strong>首部(header)</strong></li>
<li>可选的、包含数据的<strong>主体(body)</strong><br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FthreePartsOfMessage.png" alt="HTTP报文的三个部分"></li>
</ul>
<h3 id="u62A5_u6587_u7684_u8BED_u6CD5"><a href="#u62A5_u6587_u7684_u8BED_u6CD5" class="headerlink" title="报文的语法"></a>报文的语法</h3><p>HTTP报文类型:</p>
<ol>
<li>请求报文(request message)</li>
<li>响应报文(response message)</li>
</ol>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpTransactionWithRequestResponseMessage.png" alt="包含请求和响应报文的HTTP事务"></p>
<p>请求报文的格式：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">method</span>&gt; &lt;request-<span class="type">URL</span>&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure></p>
<p>响应报文的格式(只有起始行的语法不同)<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;version&gt;</span> <span class="tag">&lt;status&gt;</span> <span class="tag">&lt;reason-phrase&gt;</span></span><br><span class="line"><span class="tag">&lt;headers&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;entity-body&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>各部分的简要描述</p>
<ul>
<li>方法(method)<br>  客户端希望服务器对资源执行的动作</li>
<li>请求URL(request-URL)<br>  命名了所请求资源，或者URL路径组件的完整URL</li>
<li>版本(version)<br>  报文所使用的HTTP版本，格式如下：<code>HTTP/&lt;major&gt;.&lt;minor&gt;</code></li>
<li>状态码(status-code)<br>  这三位数字描述了请求过程中所发生的情况</li>
<li>原因短语(reason-phrase)<br>  数字状态码的可读版本，包含行终止序列之前的所有文本</li>
<li>首部(header)<br>  可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号(:)，然后是一个可选的空格，接着是一个值，最后是一个CRLF。</li>
<li>实体的主体部分(entity-body)<br>  实体的主体部分包含一个由任意数据组成的数据块。</li>
</ul>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FrequestResponseMessageDemo.png" alt="请求和响应报文示例"></p>
<h3 id="u8D77_u59CB_u884C"><a href="#u8D77_u59CB_u884C" class="headerlink" title="起始行"></a>起始行</h3><p>所有的HTTP报文都以一个起始行开始。<br>请求报文的起始行说明了要做什么。<br>响应报文的起始行说明发生了什么。</p>
<h4 id="u8BF7_u6C42_u884C"><a href="#u8BF7_u6C42_u884C" class="headerlink" title="请求行"></a>请求行</h4><p>请求报文的起始行(请求行)包含了一个方法和一个请求URL以及HTTP的版本。</p>
<h4 id="u54CD_u5E94_u884C"><a href="#u54CD_u5E94_u884C" class="headerlink" title="响应行"></a>响应行</h4><p>响应报文的起始行(响应行)包含了响应报文使用的HTTP版本、数字状态码以及描述操作状态的文本形式的原因短语。</p>
<h4 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h4><p>请求的起始行以方法作为开始<br><strong>常用的HTTP方法</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">是否包含主体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:left">从服务器获取一份文档</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:left">只从服务器获取文档的首部</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:left">向服务器发送需要处理的数据</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">PUT</td>
<td style="text-align:left">将请求的主体部分储存在服务器上</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">TRACE</td>
<td style="text-align:left">对可能经过代理服务器传送到服务器上去的报文进行追踪</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">OPTIONS</td>
<td style="text-align:left">决定可以在服务器上执行哪些方法</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:left">从服务器上删除一份文档</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<h4 id="u72B6_u6001_u7801"><a href="#u72B6_u6001_u7801" class="headerlink" title="状态码"></a>状态码</h4><p>状态码位于响应的起始行中<br><strong>状态码分类</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">整体范围</th>
<th style="text-align:center">已定义范围</th>
<th style="text-align:left">分类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100~199</td>
<td style="text-align:center">100~101</td>
<td style="text-align:left">信息提示</td>
</tr>
<tr>
<td style="text-align:center">200~299</td>
<td style="text-align:center">200~206</td>
<td style="text-align:left">成功</td>
</tr>
<tr>
<td style="text-align:center">300~399</td>
<td style="text-align:center">300~305</td>
<td style="text-align:left">重定向</td>
</tr>
<tr>
<td style="text-align:center">400~499</td>
<td style="text-align:center">400~415</td>
<td style="text-align:left">客户端错误</td>
</tr>
<tr>
<td style="text-align:center">500~599</td>
<td style="text-align:center">500~505</td>
<td style="text-align:left">服务器错误</td>
</tr>
</tbody>
</table>
<p><strong>常见状态码</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">成功。请求的所有数据都在响应主体中</td>
</tr>
<tr>
<td style="text-align:center">401</td>
<td style="text-align:left">Unauthorized(未授权)</td>
<td style="text-align:left">需要输入用户名和密码</td>
</tr>
<tr>
<td style="text-align:center">404</td>
<td style="text-align:left">Not Found(未找到)</td>
<td style="text-align:left">服务器无法找到所请求URL对应的资源</td>
</tr>
</tbody>
</table>
<h4 id="u539F_u56E0_u77ED_u8BED"><a href="#u539F_u56E0_u77ED_u8BED" class="headerlink" title="原因短语"></a>原因短语</h4><p>原因短语是响应起始行中的最后一个组件。它为状态码提供了文本形式的解释。</p>
<h4 id="u7248_u672C_u53F7"><a href="#u7248_u672C_u53F7" class="headerlink" title="版本号"></a>版本号</h4><p>版本号会以HTTP/x.y的形式出现在请求和响应报文的起始行中</p>
<h3 id="u9996_u90E8"><a href="#u9996_u90E8" class="headerlink" title="首部"></a>首部</h3><h4 id="u9996_u90E8_u5206_u7C7B"><a href="#u9996_u90E8_u5206_u7C7B" class="headerlink" title="首部分类"></a>首部分类</h4><ul>
<li>通用首部<br>既可以出现在请求报文中，也可以出现在响应报文中</li>
<li>请求首部<br>提供更多有关请求的信息</li>
<li>响应首部<br>提供更多有关响应的信息</li>
<li>实体首部<br>描述主体的长度和内容，或者资源自身</li>
<li>扩展首部<br>规范中没有定义的新首部</li>
</ul>
<p><strong> 常见的首部实例</strong><br>|首部实例|描述|<br>|:—|:—|<br>|Date:Tue,30ct 1997 02:16:03 GMT|服务器产生响应的日期|<br>|Content-length:15040|实体的主体部分包含了15040字节的数据|<br>|Content-type:image/gif|实体的主体部分是一个GIF图片|<br>|Accept:image/gif,image/jpeg,text/html|客户端可以接收GIF图片和JPEG图片以及HTML|</p>
<h4 id="u9996_u90E8_u5EF6_u7EED_u884C"><a href="#u9996_u90E8_u5EF6_u7EED_u884C" class="headerlink" title="首部延续行"></a>首部延续行</h4><p>将长的首部行分为多行可以提高可读性，多出来的每行前面至少要有一个空格或制表符(tab):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: image/gif</span><br><span class="line">Content-Length: <span class="number">8572</span></span><br><span class="line">Server: Test Server</span><br><span class="line">    Version <span class="number">1.0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u5B9E_u4F53_u7684_u4E3B_u4F53_u90E8_u5206"><a href="#u5B9E_u4F53_u7684_u4E3B_u4F53_u90E8_u5206" class="headerlink" title="实体的主体部分"></a>实体的主体部分</h3><p>实体的主体就是HTTP要传输的内容。可选。</p>
<h3 id="u7248_u672C0-9_u7684_u62A5_u6587"><a href="#u7248_u672C0-9_u7684_u62A5_u6587" class="headerlink" title="版本0.9的报文"></a>版本0.9的报文</h3><p>HTTP/0.9报文也由请求和响应组成，但请求中只包含方法和请求URL,响应中只包含实体。它没有版本信息，没有状态码或原因短语，也没有首部。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/httpChapter3/http09Transaction.png" alt="HTTP/0.9事务"></p>
<h2 id="u65B9_u6CD5-1"><a href="#u65B9_u6CD5-1" class="headerlink" title="方法"></a>方法</h2><h3 id="u5B89_u5168_u65B9_u6CD5"><a href="#u5B89_u5168_u65B9_u6CD5" class="headerlink" title="安全方法"></a>安全方法</h3><p>GET方法和HEAD方法被认为是安全的，使用GET或HEAD方法的HTTP请求都不会产生什么动作。</p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>通常用于请求服务器发送某一资源<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpGetDemo.png" alt="HTTP Get 示例"></p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD方法和GET方法类似，但服务器在响应中只返回首部，不返回实体的主体部分。</p>
<ul>
<li>在不获取资源的情况下了解资源的情况(比如，判断其类型)</li>
<li>通过查看响应中的状态码，看看某个对象是否存在</li>
<li>通过查看首部，测试资源是否被修改了</li>
</ul>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpHeadDemo.png" alt="HTTP HEAD 示例"></p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>PUT方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名的心文档，或者，如果那个URL已经存在的话，就用这个主体来替代它<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpPutDemo.png" alt="HTTP PUT 示例"></p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>通常用它来支持HTML的表单<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpPostDemo.png" alt="HTTP POST 示例"></p>
<h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子<br>TRACE请求中不能带有实体的主体部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpTraceDemo.png" alt="HTTP TRACE 示例"></p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>OPTIONS方法请求Web服务器告知其支持的各种功能<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpOptionsDemo.png" alt="HTTP OPTIONS 示例"></p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE方法请服务器删除请求URL指定的资源。<br>客户端应用程序无法保证删除操作一定会被执行。<br>HTTP规范允许服务器在不通知客户端的情况下撤销请求。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpDeleteDemo.png" alt="HTTP DELETE 示例"></p>
<h3 id="u6269_u5C55_u65B9_u6CD5"><a href="#u6269_u5C55_u65B9_u6CD5" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>Web 发布扩展方法示例</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LOCK</td>
<td style="text-align:left">允许用户“锁定”资源–比如可以在编辑某个资源的时候将其锁定，以防别人同事对其进行修改</td>
</tr>
<tr>
<td style="text-align:center">MKCOL</td>
<td style="text-align:left">允许用户创建资源</td>
</tr>
<tr>
<td style="text-align:center">COPY</td>
<td style="text-align:left">便于在服务器上复制资源</td>
</tr>
<tr>
<td style="text-align:center">MOVE</td>
<td style="text-align:left">在服务器上移动资源</td>
</tr>
</tbody>
</table>
<p>并不是所有扩展方法都是在正式规范中定义的。<br>处理扩展方法惯例：“对发送的内容要求严一点，对接收的内容宽容一些”</p>
<h2 id="u72B6_u6001_u7801-1"><a href="#u72B6_u6001_u7801-1" class="headerlink" title="状态码"></a>状态码</h2><h3 id="100_7E199__u2013_u4FE1_u606F_u6027_u72B6_u6001_u7801"><a href="#100_7E199__u2013_u4FE1_u606F_u6027_u72B6_u6001_u7801" class="headerlink" title="100~199 –信息性状态码"></a>100~199 –信息性状态码</h3><table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:left">Continue</td>
<td style="text-align:left">说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应。</td>
</tr>
<tr>
<td style="text-align:center">101</td>
<td style="text-align:left">Switching Protocals</td>
<td style="text-align:left">说明服务器正在根据客户端的指定，将协议切换成Update首部所列的协议</td>
</tr>
</tbody>
</table>
<ol>
<li>客户端与100 Continue<br>如果客户端在向服务器发送一个实体，并且愿意在发送实体之前等待100Continue响应，那么客户端就要发送一个携带了值为100 Continue的Expect请求首部。<br>如果客户端没有发送实体，就不应该发送100 Continue Expect首部。</li>
<li>服务器与100 Continue<br>如果服务器收到了一条带有值为100 Continue的Expect首部的请求，它会用100 Continue响应或一条错误码来进行响应。</li>
<li>代理与100 Continue</li>
</ol>
<ul>
<li>如果代理知道下一跳服务器是HTTP/1.1兼容的，或者并不知道下一跳服务器与哪个版本兼容，它都应该将Expect首部放在请求中向下转发。</li>
<li>如果它知道下一跳服务器只能与HTTP/1.1之前的版本兼容，就应该你以417Expectation Failed错误进行响应。</li>
<li>如果代理决定代表与HTTP/1.0或之前版本兼容的客户端，在其请求中放入Expect首部和100 Continue值，那么（如果它从服务器收到了100 Continue响应）它就不应该将100 Continue响应转发给客户端。</li>
</ul>
<h3 id="200_7E299_u2013_u6210_u529F_u72B6_u6001_u7801"><a href="#200_7E299_u2013_u6210_u529F_u72B6_u6001_u7801" class="headerlink" title="200~299–成功状态码"></a>200~299–成功状态码</h3><table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">请求没问题，实体的主体部分包含了所请求的资源</td>
</tr>
<tr>
<td style="text-align:center">201</td>
<td style="text-align:left">Created</td>
<td style="text-align:left">用于创建服务器对象的（比如PUT）。响应的实体主体部分中应该包含各种引用了已创建的资源URL,Location首部包含的则是最具体的引用</td>
</tr>
<tr>
<td style="text-align:center">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">请求已被接受，但服务器还未对其执行任何动作。</td>
</tr>
<tr>
<td style="text-align:center">203</td>
<td style="text-align:left">Non-Authoritative Infomation</td>
<td style="text-align:left">实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法或者没有对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况</td>
</tr>
<tr>
<td style="text-align:center">204</td>
<td style="text-align:left">No Content</td>
<td style="text-align:left">响应报文中包含若干首部和一个状态行，但没有实体的主体部分。</td>
</tr>
<tr>
<td style="text-align:center">205</td>
<td style="text-align:left">Reset Content</td>
<td style="text-align:left">负责告知浏览器清除当前页面中的所有HTML表单元素</td>
</tr>
<tr>
<td style="text-align:center">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">成功执行了一个部分或Range(范围)请求。206响应中必须包含Content-Range,Date以及ETag或Content-Location首部</td>
</tr>
</tbody>
</table>
<h3 id="300_7E399__u2013__u91CD_u5B9A_u5411_u72B6_u6001_u7801"><a href="#300_7E399__u2013__u91CD_u5B9A_u5411_u72B6_u6001_u7801" class="headerlink" title="300~399 – 重定向状态码"></a>300~399 – 重定向状态码</h3><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2Fhttp3xxRedirectToNewPlace.png" alt="重定向到新位置"></p>
<p>可以通过某些重定向状态码对资源的应用程序本地副本与源端服务器上的资源进行验证<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2Fhttp3xxRedirectToLocalBackup.png" alt="重定向为使用本地副本的请求"></p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">300</td>
<td style="text-align:left">Multiple Choices</td>
<td style="text-align:left">客户端请求一个实际指向多个资源的URL时会返回这个状态码</td>
</tr>
<tr>
<td style="text-align:center">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left">在请求的URL已被移除时使用。响应的Location首部中应该包含资源现在所处的URL</td>
</tr>
<tr>
<td style="text-align:center">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">与301状态码类似，但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍就使用老的URL</td>
</tr>
<tr>
<td style="text-align:center">303</td>
<td style="text-align:left">See Other</td>
<td style="text-align:left">告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的Location首部。</td>
</tr>
<tr>
<td style="text-align:center">304</td>
<td style="text-align:left">Not Modified</td>
<td style="text-align:left">客户端可以通过所包含的请求首部，使其请求变成有条件的。带有这个状态码的响应不应该包含实体的主体部分</td>
</tr>
<tr>
<td style="text-align:center">305</td>
<td style="text-align:left">Use Proxy</td>
<td style="text-align:left">用来说明必须通过一个代理来访问资源，代理的位置由Location首部给出</td>
</tr>
<tr>
<td style="text-align:center">306</td>
<td style="text-align:left">（未使用）</td>
<td style="text-align:left">当前未使用</td>
</tr>
<tr>
<td style="text-align:center">307</td>
<td style="text-align:left">Temporary Redirect</td>
<td style="text-align:left">与301状态码类似，但客户端应该使用Location首部给出的URL来临时定位资源。将来的请求应该使用老的URL</td>
</tr>
</tbody>
</table>
<h3 id="400_7E499__u2013_u5BA2_u6237_u7AEF_u9519_u8BEF_u72B6_u6001_u7801"><a href="#400_7E499__u2013_u5BA2_u6237_u7AEF_u9519_u8BEF_u72B6_u6001_u7801" class="headerlink" title="400~499 –客户端错误状态码"></a>400~499 –客户端错误状态码</h3><table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">用于告知客户端它发送了一个错误的请求</td>
</tr>
<tr>
<td style="text-align:center">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问之前，对自己进行认证。</td>
</tr>
<tr>
<td style="text-align:center">402</td>
<td style="text-align:left">Payment Required</td>
<td style="text-align:left">现在这个状态码未使用，但已经被保留，以未来之用</td>
</tr>
<tr>
<td style="text-align:center">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">用于说明请求被服务器拒绝了。</td>
</tr>
<tr>
<td style="text-align:center">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">用于说明服务器无法找到所请求的URL</td>
</tr>
<tr>
<td style="text-align:center">405</td>
<td style="text-align:left">Method Not Allowed</td>
<td style="text-align:left">发起的请求中带有所请求的URL不支持的方法时，使用此状态码，应该在响应中包含Allow首部，以告知客户端对所请求的资源可以使用哪些方法。</td>
</tr>
<tr>
<td style="text-align:center">406</td>
<td style="text-align:left">Not Acceptable</td>
<td style="text-align:left">客户端可以指定参数来说明它们愿意接收什么类型的实体。</td>
</tr>
<tr>
<td style="text-align:center">407</td>
<td style="text-align:left">Proxy Authentication Required</td>
<td style="text-align:left">与401状态码类似，但用于要求对资源进行认证的代理服务器</td>
</tr>
<tr>
<td style="text-align:center">408</td>
<td style="text-align:left">Request Timeout</td>
<td style="text-align:left">如果客户端完成请求所花时间太长，服务器可以回送此状态码，并关闭连接</td>
</tr>
<tr>
<td style="text-align:center">409</td>
<td style="text-align:left">Confilict</td>
<td style="text-align:left">用于说明请求可能在资源上引发的一些冲突。服务器担心请求会引发冲突时，可以发送此状态码。响应中应该包含描述冲突的主体</td>
</tr>
<tr>
<td style="text-align:center">410</td>
<td style="text-align:left">Gone</td>
<td style="text-align:left">与404类似，只是服务器曾经拥有过此资源。</td>
</tr>
<tr>
<td style="text-align:center">411</td>
<td style="text-align:left">Length Required</td>
<td style="text-align:left">服务器要求在请求报文中包含Content-Length首部时使用</td>
</tr>
<tr>
<td style="text-align:center">412</td>
<td style="text-align:left">Precondition Failed</td>
<td style="text-align:left">客户端发起条件请求，且其中一个条件失败了的时候使用。客户端包含了Expect首部时发起的就是条件请求</td>
</tr>
<tr>
<td style="text-align:center">413</td>
<td style="text-align:left">Request Entity Too Large</td>
<td style="text-align:left">客户端发送的实体主体部分比服务器能够或者希望处理的要大时，使用此状态码</td>
</tr>
<tr>
<td style="text-align:center">414</td>
<td style="text-align:left">Request URI Too Long</td>
<td style="text-align:left">客户端所发请求中的请求URL比服务器能够或者希望处理的要长时，使用此状态码</td>
</tr>
<tr>
<td style="text-align:center">415</td>
<td style="text-align:left">Unsupported Media Type</td>
<td style="text-align:left">服务器无法理解或无法支持客户端所发实体的内容类型时，使用此状态码</td>
</tr>
<tr>
<td style="text-align:center">416</td>
<td style="text-align:left">Requested Range Not Satisfiable</td>
<td style="text-align:left">请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时，使用此状态码</td>
</tr>
<tr>
<td style="text-align:center">417</td>
<td style="text-align:left">Expectation Failed</td>
<td style="text-align:left">请求的Except请求首部包含了一个期望，但服务器无法满足此期望时，使用此状态码</td>
</tr>
</tbody>
</table>
<h3 id="500_7E599__u2013_u670D_u52A1_u5668_u9519_u8BEF_u72B6_u6001_u7801"><a href="#500_7E599__u2013_u670D_u52A1_u5668_u9519_u8BEF_u72B6_u6001_u7801" class="headerlink" title="500~599 –服务器错误状态码"></a>500~599 –服务器错误状态码</h3><table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态</td>
</tr>
<tr>
<td style="text-align:center">501</td>
<td style="text-align:left">Not Implemented</td>
<td style="text-align:left">客户端发起的请求超出服务器的能力范围</td>
</tr>
<tr>
<td style="text-align:center">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（比如它无法连接到其父网关）时，使用此状态码</td>
</tr>
<tr>
<td style="text-align:center">503</td>
<td style="text-align:left">Service Unavailable</td>
<td style="text-align:left">用来说明服务器现在无法为请求提供服务，但将来可以。</td>
</tr>
<tr>
<td style="text-align:center">504</td>
<td style="text-align:left">Gateway Timeout</td>
<td style="text-align:left">与状态码408类似，只是这里的响应来自一个网关或代理，它们在另一服务器对其请求进行响应时超时了</td>
</tr>
<tr>
<td style="text-align:center">505</td>
<td style="text-align:left">HTTP Version Not Supported</td>
<td style="text-align:left">服务器收到的请求使用了它无法或不愿支持的协议版本时，使用此状态码</td>
</tr>
</tbody>
</table>
<h2 id="u9996_u90E8-1"><a href="#u9996_u90E8-1" class="headerlink" title="首部"></a>首部</h2><p>首部和方法配工作，共同决定了客户端和服务器能做什么事情。<br>5种主要的类型</p>
<ul>
<li>通用首部</li>
<li>请求首部</li>
<li>响应首部</li>
<li>实体首部</li>
<li>扩展首部</li>
</ul>
<h3 id="u901A_u7528_u9996_u90E8"><a href="#u901A_u7528_u9996_u90E8" class="headerlink" title="通用首部"></a>通用首部</h3><p><strong>通用的信息性首部*</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Connection</td>
<td style="text-align:left">允许客户端和服务器指定与请求/响应连接有关的选项</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">提供日期和时间标志，说明报文是什么时间创建的</td>
</tr>
<tr>
<td style="text-align:left">MIME-Version</td>
<td style="text-align:left">给出了发送端使用的MIME版本</td>
</tr>
<tr>
<td style="text-align:left">Trailer</td>
<td style="text-align:left">如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖挂(tailer)部分的首部集合</td>
</tr>
<tr>
<td style="text-align:left">Transfer-Encoding</td>
<td style="text-align:left">告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</td>
</tr>
<tr>
<td style="text-align:left">Update</td>
<td style="text-align:left">给出了发送端可能想要“升级”使用的新版本或协议</td>
</tr>
<tr>
<td style="text-align:left">Via</td>
<td style="text-align:left">显示了报文经过的中间节点（代理、网关）</td>
</tr>
</tbody>
</table>
<p><strong>通用缓存首部</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">用于随报文传送缓存指示</td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">另一种随报文传送指示的方式，但不专用于缓存</td>
</tr>
</tbody>
</table>
<h3 id="u8BF7_u6C42_u9996_u90E8"><a href="#u8BF7_u6C42_u9996_u90E8" class="headerlink" title="请求首部"></a>请求首部</h3><p><strong> 请求的信息性首部</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Client-IP</td>
<td style="text-align:left">提供了运行客户端的机器的IP地址</td>
</tr>
<tr>
<td style="text-align:left">From</td>
<td style="text-align:left">提供了客户端用户的E-mail地址</td>
</tr>
<tr>
<td style="text-align:left">Host</td>
<td style="text-align:left">给出了接收请求的服务器的主机名和端口号</td>
</tr>
<tr>
<td style="text-align:left">Referer</td>
<td style="text-align:left">提供了包含当前请求URI的文档的URL</td>
</tr>
<tr>
<td style="text-align:left">UA-Color</td>
<td style="text-align:left">提供了与客户端显示器的显示颜色有关的信息</td>
</tr>
<tr>
<td style="text-align:left">UA-CPU</td>
<td style="text-align:left">给出了客户端CPU的类型或制造商</td>
</tr>
<tr>
<td style="text-align:left">UA-Disp</td>
<td style="text-align:left">提供了与客户端显示器（屏幕）能力有关的信息</td>
</tr>
<tr>
<td style="text-align:left">UA-OS</td>
<td style="text-align:left">给出了运行在客户端机器上的操作系统名称及版本</td>
</tr>
<tr>
<td style="text-align:left">UA-Pixels</td>
<td style="text-align:left">提供了客户端显示器的像素信息</td>
</tr>
<tr>
<td style="text-align:left">User-Agent</td>
<td style="text-align:left">将发起请求的应用程序名称告知服务器</td>
</tr>
</tbody>
</table>
<p><strong>Accept首部</strong><br>Accept首部为客户端提供了一种将其喜好和能力告知服务器的方式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept</td>
<td style="text-align:left">告诉服务器能够发送哪些媒体类型</td>
</tr>
<tr>
<td style="text-align:left">Accept-Charset</td>
<td style="text-align:left">告诉服务器能够发送哪些字符集</td>
</tr>
<tr>
<td style="text-align:left">Accept-Encoding</td>
<td style="text-align:left">告诉服务器能够发送哪些编码方式</td>
</tr>
<tr>
<td style="text-align:left">Accept-Language</td>
<td style="text-align:left">告诉服务器能够发送哪些语言</td>
</tr>
<tr>
<td style="text-align:left">TE</td>
<td style="text-align:left">告诉服务器可以使用哪些扩展传输编码</td>
</tr>
</tbody>
</table>
<p><strong>条件请求首部</strong><br>有时客户端希望为请求加上某些限制。</p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Expect</td>
<td style="text-align:left">允许客户端列出某请求所要求的服务器行为</td>
</tr>
<tr>
<td style="text-align:left">If-Match</td>
<td style="text-align:left">如果实体标记在文档当前的实体标记相匹配，就获得这份文档</td>
</tr>
<tr>
<td style="text-align:left">If-Modified-Since</td>
<td style="text-align:left">除非在某个指定的日期之后资源被修改过，否则就限制这个请求</td>
</tr>
<tr>
<td style="text-align:left">If-None-Match</td>
<td style="text-align:left">如果提供的实体标记与当前文档的实体标记不相符，就获取文档</td>
</tr>
<tr>
<td style="text-align:left">If-Range</td>
<td style="text-align:left">允许对文档的某个范围进行条件请求</td>
</tr>
<tr>
<td style="text-align:left">If-Unmodified-Since</td>
<td style="text-align:left">除非在某个指定日期之后资源没有被修改过，否则就限制这个请求</td>
</tr>
<tr>
<td style="text-align:left">Range</td>
<td style="text-align:left">如果服务器支持范围请求，就请求资源的指定范围</td>
</tr>
</tbody>
</table>
<p><strong>安全请求首部</strong><br>HTTP本身这支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。</p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Authorization</td>
<td style="text-align:left">包含了客户端提供给服务器，以便对其自身进行认证的数据</td>
</tr>
<tr>
<td style="text-align:left">Cookie</td>
<td style="text-align:left">客户端用它向服务器传送一个令牌–它并不是真正的安全首部，但确实隐含了安全功能</td>
</tr>
<tr>
<td style="text-align:left">Cookie2</td>
<td style="text-align:left">用来说明请求端支持的cookie版本</td>
</tr>
</tbody>
</table>
<p><strong>代理请求首部</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Max-Forward</td>
<td style="text-align:left">在通往源端服务器的路径上，将请求转发给其代理或网关的最大次数–与TRACE方法一同使用</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authorization</td>
<td style="text-align:left">与Authorization首部相同，但这个首部是在与代理进行认证时使用的</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Connection</td>
<td style="text-align:left">与Connection首部相同，但这个首部是在代理建立连接时使用的</td>
</tr>
</tbody>
</table>
<h3 id="u54CD_u5E94_u9996_u90E8"><a href="#u54CD_u5E94_u9996_u90E8" class="headerlink" title="响应首部"></a>响应首部</h3><p>响应首部有助于客户端处理响应，并在将来发起更好的请求。</p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">（从最初创建开始）响应持续时间</td>
</tr>
<tr>
<td style="text-align:left">Public</td>
<td style="text-align:left">服务器为其资源支持的请求方法列表</td>
</tr>
<tr>
<td style="text-align:left">Retry-After</td>
<td style="text-align:left">如果资源不可用的话，在此日期或时间重试</td>
</tr>
<tr>
<td style="text-align:left">Server</td>
<td style="text-align:left">服务器应用程序软件的名称和版本</td>
</tr>
<tr>
<td style="text-align:left">Title</td>
<td style="text-align:left">对HTML文档来说，就是HTML文档的源端给出的标题</td>
</tr>
<tr>
<td style="text-align:left">Warning</td>
<td style="text-align:left">比原因短语中更详细一些的警告报文</td>
</tr>
</tbody>
</table>
<p><strong>协商首部</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept-Range</td>
<td style="text-align:left">对此资源来说，服务器或接受的范围类型</td>
</tr>
<tr>
<td style="text-align:left">Vary</td>
<td style="text-align:left">服务器查看的其他首部的列表，可能会使响应发生变化，也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发给客户端</td>
</tr>
</tbody>
</table>
<p><strong>安全响应首部</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Proxy-Authenticate</td>
<td style="text-align:left">来自代理的对客户端的质询列表</td>
</tr>
<tr>
<td style="text-align:left">Set-Cookie</td>
<td style="text-align:left">不是真正的安全首部，但隐含有安全功能，可以在客户端设置一个令牌，以便服务器对客户端进行标识</td>
</tr>
<tr>
<td style="text-align:left">Set-Cookie2</td>
<td style="text-align:left">与Set-Cookie类似</td>
</tr>
<tr>
<td style="text-align:left">WWW-Authenticate</td>
<td style="text-align:left">来自服务器的客户端的质询列表</td>
</tr>
</tbody>
</table>
<h3 id="u5B9E_u4F53_u9996_u90E8"><a href="#u5B9E_u4F53_u9996_u90E8" class="headerlink" title="实体首部"></a>实体首部</h3><p><strong>信息性首部</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Allow</td>
<td style="text-align:left">列出了可以对此实体执行的请求方法</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">告知客户端实体实际上位于何处，用于将接收端定向到资源的（可能是新的）位置（URL）上去</td>
</tr>
</tbody>
</table>
<p><strong>内容首部</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Content-Base</td>
<td style="text-align:left">解析主体中的相对URL时使用的基础URL</td>
</tr>
<tr>
<td style="text-align:left">Content-Encoding</td>
<td style="text-align:left">对主体执行的任意编码方式</td>
</tr>
<tr>
<td style="text-align:left">Content-Language</td>
<td style="text-align:left">理解主体时最适宜使用的自然语言</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">主体的长度或尺寸</td>
</tr>
<tr>
<td style="text-align:left">Content-Location</td>
<td style="text-align:left">资源实际所处的位置</td>
</tr>
<tr>
<td style="text-align:left">Content-MD5</td>
<td style="text-align:left">主体的MD5校验和</td>
</tr>
<tr>
<td style="text-align:left">Content-Range</td>
<td style="text-align:left">在整个资源中此实体表示的字节范围</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">这个主体的对象类型</td>
</tr>
</tbody>
</table>
<p><strong>实体缓存首部</strong><br>通用的缓存首部说明了如何或什么时候进行缓存。实体的缓存首部提供了与被缓存实体有关的信息。</p>
<table>
<thead>
<tr>
<th style="text-align:left">首部</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ETag</td>
<td style="text-align:left">与此实体相关的实体标记</td>
</tr>
<tr>
<td style="text-align:left">Expire</td>
<td style="text-align:left">实体不再有效，要从原始的源端再次获取此实体的日期和时间</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">这个实体最后一次被修改的日期和时间</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="HTTP__u62A5_u6587"><a href="#HTTP__u62A5_u6587" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h1><h2 id="u62A5_u6587_u6D41"><a href="#u62A5_u6587_u6D41" class="headerlink" title="报文流"></a>报文流</h2><p>HTTP报文是在HTTP应用程序之间发送的数据块</p>
<h3 id="u62A5_u6587_u6D41_u5165_u6E90_u7AEF_u670D_u52A1_u5668"><a href="#u62A5_u6587_u6D41_u5165_u6E90_u7AEF_u670D_u52A1_u5668" class="headerlink" title="报文流入源端服务器"></a>报文流入源端服务器</h3><p>HTTP使用术语<strong>流入(inbound)</strong>和<strong>流出(outbound)</strong>来描述<strong>事务处理(transaction)</strong><br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter3%2FhttpTransaction.png" alt="报文流入源端服务器并流回到客户端"></p>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://bettersth.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP权威指南 笔记二]]></title>
    <link href="http://bettersth.xyz/2016/03/31/http-the-definitive-guide-notes02/"/>
    <id>http://bettersth.xyz/2016/03/31/http-the-definitive-guide-notes02/</id>
    <published>2016-03-31T05:12:55.000Z</published>
    <updated>2016-03-31T07:25:03.381Z</updated>
    <content type="html"><![CDATA[<h1 id="URL_u4E0E_u8D44_u6E90"><a href="#URL_u4E0E_u8D44_u6E90" class="headerlink" title="URL与资源"></a>URL与资源</h1><h2 id="u6D4F_u89C8_u56E0_u7279_u7F51_u8D44_u6E90"><a href="#u6D4F_u89C8_u56E0_u7279_u7F51_u8D44_u6E90" class="headerlink" title="浏览因特网资源"></a>浏览因特网资源</h2><p>URL是浏览器寻找信息时所需的资源位置。<br>URI是一类更通用的资源标识符，URL和URN是其两个主要的子集。<br> <img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter2%2FhowURLWorks.png" alt="URL访问资源"></p>
<p> URL统一的资源命名方式：“方案://服务器位置/路径”<br><a id="more"></a></p>
<h2 id="URL_u7684_u8BED_u6CD5"><a href="#URL_u7684_u8BED_u6CD5" class="headerlink" title="URL的语法"></a>URL的语法</h2><p>通用格式<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;<span class="symbol">://&lt;user&gt;</span><span class="symbol">:&lt;password&gt;</span>@&lt;host&gt;<span class="symbol">:&lt;port&gt;/&lt;path&gt;</span>;&lt;params&gt;?&lt;query&gt;<span class="comment">#&lt;frag&gt;</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">组件</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方案</td>
<td style="text-align:left">访问服务器以访问资源时要使用哪种协议</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">用户</td>
<td style="text-align:left">某些方案访问资源时需要的用户名</td>
<td style="text-align:center">匿名</td>
</tr>
<tr>
<td style="text-align:center">密码</td>
<td style="text-align:left">用户名后面可能要包含的密码，中间由冒号(:)分隔</td>
<td style="text-align:center"><e-mail地址></e-mail地址></td>
</tr>
<tr>
<td style="text-align:center">主机</td>
<td style="text-align:left">资源宿主服务器的主机名或点分IP地址</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">端口</td>
<td style="text-align:left">资源宿主服务器正在监听的端口号，很多方案都有默认端口号(HTTP的默认端口号为80)</td>
<td style="text-align:center">每个方案特有</td>
</tr>
<tr>
<td style="text-align:center">路径</td>
<td style="text-align:left">服务器上资源的本地名，由一个斜杠(/)将其与前面的URL组件分隔开来，路径组件的语法是与服务器和方案有关的</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">参数</td>
<td style="text-align:left">某些方案会用这个组件来指定输入参数。参数为名/值对。URL中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用分号(;)分隔</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">查询</td>
<td style="text-align:left">某些方案会用这个组件传递参数以激活应用程序。查询组件的内容没有通用格式。用字符“?”将其与URL的其余部分分隔开来</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">片段</td>
<td style="text-align:left">一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器，这个字段是在客户端内部使用的。</td>
<td style="text-align:center">无</td>
</tr>
</tbody>
</table>
<h3 id="u65B9_u6848_u2013_u4F7F_u7528_u4EC0_u4E48_u534F_u8BAE"><a href="#u65B9_u6848_u2013_u4F7F_u7528_u4EC0_u4E48_u534F_u8BAE" class="headerlink" title="方案–使用什么协议"></a>方案–使用什么协议</h3><p>方案规定如何访问指定资源。<br>方案组件必须以一个字母符号开始，由第一个“:”符号将其与URL的其余部分分割开来。<br>方案名是大小写无关的</p>
<h3 id="u4E3B_u673A_u4E0E_u7AEF_u53E3"><a href="#u4E3B_u673A_u4E0E_u7AEF_u53E3" class="headerlink" title="主机与端口"></a>主机与端口</h3><p>主机组件标识了因特网上能够访问资源的宿主机器<br>端口组件标识了服务器正在监听的网络端口</p>
<h3 id="u7528_u6237_u540D_u548C_u5BC6_u7801"><a href="#u7528_u6237_u540D_u548C_u5BC6_u7801" class="headerlink" title="用户名和密码"></a>用户名和密码</h3><p>常用于FTP服务器</p>
<ul>
<li>没有用户或密码组件<br>  ftp://ftp.prep.ai.mit.edu/pub/gnu</li>
<li>指定为anonymous的用户名<br> ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu</li>
<li>指定了用户名和密码<br>  ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu</li>
</ul>
<h3 id="u8DEF_u5F84"><a href="#u8DEF_u5F84" class="headerlink" title="路径"></a>路径</h3><p>URL的路径组件说明了资源位于服务器的什么地方</p>
<h3 id="u53C2_u6570"><a href="#u53C2_u6570" class="headerlink" title="参数"></a>参数</h3><p>ftp://prep.ai.mit.edu/pub/gnu;type=d<br><a href="http://www.joes.hardware.com/hammers;sale=false/index.html;graphics=true" target="_blank" rel="external">http://www.joes.hardware.com/hammers;sale=false/index.html;graphics=true</a></p>
<h3 id="u67E5_u8BE2_u5B57_u7B26_u4E32"><a href="#u67E5_u8BE2_u5B57_u7B26_u4E32" class="headerlink" title="查询字符串"></a>查询字符串</h3><p>URL中问号(?)右边的内容称为查询(query)组件<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter2%2FURLQuery.png" alt="URL查询组件"></p>
<h3 id="u7247_u6BB5"><a href="#u7247_u6BB5" class="headerlink" title="片段"></a>片段</h3><p>URL支持使用片段(frag)组件来表示一个资源内部的片段<br>服务器处理的是整个对象，URL片段仅由客户端使用<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter2%2FURLFrag.png" alt="片段Frag"></p>
<h2 id="URL_u5FEB_u6377_u65B9_u5F0F"><a href="#URL_u5FEB_u6377_u65B9_u5F0F" class="headerlink" title="URL快捷方式"></a>URL快捷方式</h2><h3 id="u76F8_u5BF9URL"><a href="#u76F8_u5BF9URL" class="headerlink" title="相对URL"></a>相对URL</h3><p>URL两种方式：<strong> 绝对的和相对的 </strong></p>
<ul>
<li>绝对URL中包含有访问资源所需的全部信息</li>
<li>相对URL是不完整的，要从相对URL中获取访问资源所需的全部信息，就必须相对另一个，被称为其基础(base)的URL进行解析<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter2%2FrelativeURL.png" alt="相对URL"></li>
</ul>
<p>相对URL可以通过基础URL来推导出绝对URL<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter2%2FhowRelativeURLworks.png" alt="通过基础URL推导相对URL的绝对URL"></p>
<ol>
<li>基础URL<ul>
<li>在资源中显示提供</li>
<li>封装资源的基础URL</li>
<li>没有基础URL</li>
</ul>
</li>
<li>解析相对引用<br> <img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter2%2FanalyzeURL.png" alt="相对URL转换成绝对URL"><br> 对上面例子中./hammers.html实例使用上图算法的过程：<ol>
<li>路径为./hammers.html，基础URL为<a href="http://www.joes-hardware.com/tools.html" target="_blank" rel="external">http://www.joes-hardware.com/tools.html</a></li>
<li>方案为空，沿着图标的左半边向下处理，继承基础URL方案(HTTP)</li>
<li>至少一个组件非空，一直处理到底端，继承主机和端口组件</li>
<li>将来自相对URL(路径:./hammers.html)的组件与我们继承来的组件(方案:http，主机: www.joes-hardware.com，端口: 80)合并起来，得到新的绝对URL：<a href="http://www.joes-hardware.com/hammers.html" target="_blank" rel="external">http://www.joes-hardware.com/hammers.html</a></li>
</ol>
</li>
</ol>
<h3 id="u81EA_u52A8_u6269_u5C55URL"><a href="#u81EA_u52A8_u6269_u5C55URL" class="headerlink" title="自动扩展URL"></a>自动扩展URL</h3><ul>
<li>主机名扩展</li>
<li>历史扩展</li>
</ul>
<h2 id="u5404_u79CD_u4EE4_u4EBA_u5934_u75BC_u7684_u7B26_u53F7"><a href="#u5404_u79CD_u4EE4_u4EBA_u5934_u75BC_u7684_u7B26_u53F7" class="headerlink" title="各种令人头疼的符号"></a>各种令人头疼的符号</h2><h3 id="URL_u5B57_u7B26_u96C6"><a href="#URL_u5B57_u7B26_u96C6" class="headerlink" title="URL字符集"></a>URL字符集</h3><p>常用US-ASCII字符集</p>
<h3 id="u7F16_u7801_u673A_u5236"><a href="#u7F16_u7801_u673A_u5236" class="headerlink" title="编码机制"></a>编码机制</h3><p>通过“转义”表示法来表示不安全的字符，该转义表示法包含一个百分号(%),后面跟着两个表示字符ASCII码的十六进制数</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">ASCII码</th>
<th style="text-align:left">示例URL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">126(0x7E)</td>
<td style="text-align:left"><a href="http://www.joes-hardware.com/%7Ejoe" target="_blank" rel="external">http://www.joes-hardware.com/%7Ejoe</a></td>
</tr>
<tr>
<td style="text-align:center">空格</td>
<td style="text-align:center">32(0x20)</td>
<td style="text-align:left"><a href="http://www.joes-hardware.com/more%20tools.html" target="_blank" rel="external">http://www.joes-hardware.com/more%20tools.html</a></td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">37(0x25)</td>
<td style="text-align:left"><a href="http://www.joes-hardware.com/100%25satisfaction.html" target="_blank" rel="external">http://www.joes-hardware.com/100%25satisfaction.html</a></td>
</tr>
</tbody>
</table>
<h3 id="u5B57_u7B26_u9650_u5236"><a href="#u5B57_u7B26_u9650_u5236" class="headerlink" title="字符限制"></a>字符限制</h3><ul>
<li>URL中有些字符被保留起来，有着特殊的含义。</li>
<li>有些字符不在定义的US-ASCII可打印字符集中</li>
<li>有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">保留/受限</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:left">保留作为编码字符的转义标志</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:left">保留作为路径组件中分隔路径段的定界符</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:left">保留在路径组件中使用</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td style="text-align:left">保留在路径组件中使用</td>
</tr>
<tr>
<td style="text-align:center">#</td>
<td style="text-align:left">保留作为分段定界符使用</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">保留作为查询字符串定界符使用</td>
</tr>
<tr>
<td style="text-align:center">;</td>
<td style="text-align:left">保留作为参数定界符使用</td>
</tr>
<tr>
<td style="text-align:center">:</td>
<td style="text-align:left">保留助威方案、用户/口令，已经主机/端口组件的定界符使用</td>
</tr>
<tr>
<td style="text-align:center">$,+</td>
<td style="text-align:left">保留</td>
</tr>
<tr>
<td style="text-align:center">@&amp;=</td>
<td style="text-align:left">在某些方案的上下文中有特殊的含义，保留</td>
</tr>
<tr>
<td style="text-align:center">{}^~[]’</td>
<td style="text-align:left">由于各种传输Ageng代理，比如各种网关的不安全处理，使用受限</td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt;”</td>
<td style="text-align:left">不安全，这些字符在URL范围之外通常是有意义的，比如在文档中对URL自身进行定界(比如<a href="http://www.joe-hardware.com)，所以应该对其进行编码" target="_blank" rel="external">http://www.joe-hardware.com)，所以应该对其进行编码</a></td>
</tr>
<tr>
<td style="text-align:center">0x00-0x1F,0x7F</td>
<td style="text-align:left">受限，这些十六进制范围内的字符都在US-ASCII字符集不可打印区间内</td>
</tr>
<tr>
<td style="text-align:center">&gt;0x7F</td>
<td style="text-align:left">受限，十六进制值在此范围内的字符都不在US-ASCII字符集的7二进制位范围内</td>
</tr>
</tbody>
</table>
<h2 id="u65B9_u6848_u7684_u4E16_u754C"><a href="#u65B9_u6848_u7684_u4E16_u754C" class="headerlink" title="方案的世界"></a>方案的世界</h2><p>常见的方案格式</p>
<ul>
<li>http</li>
<li>https</li>
<li>mailto</li>
<li>ftp</li>
<li>rtsp,rtspu</li>
<li>file</li>
<li>news</li>
<li>telnet</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="URL_u4E0E_u8D44_u6E90"><a href="#URL_u4E0E_u8D44_u6E90" class="headerlink" title="URL与资源"></a>URL与资源</h1><h2 id="u6D4F_u89C8_u56E0_u7279_u7F51_u8D44_u6E90"><a href="#u6D4F_u89C8_u56E0_u7279_u7F51_u8D44_u6E90" class="headerlink" title="浏览因特网资源"></a>浏览因特网资源</h2><p>URL是浏览器寻找信息时所需的资源位置。<br>URI是一类更通用的资源标识符，URL和URN是其两个主要的子集。<br> <img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter2%2FhowURLWorks.png" alt="URL访问资源"></p>
<p> URL统一的资源命名方式：“方案://服务器位置/路径”<br>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://bettersth.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP权威指南 笔记一]]></title>
    <link href="http://bettersth.xyz/2016/03/30/http-the-definitive-guide-notes01/"/>
    <id>http://bettersth.xyz/2016/03/30/http-the-definitive-guide-notes01/</id>
    <published>2016-03-30T11:29:31.000Z</published>
    <updated>2016-03-30T11:37:25.329Z</updated>
    <content type="html"><![CDATA[<h1 id="HTTP__u6982_u8FF0"><a href="#HTTP__u6982_u8FF0" class="headerlink" title="HTTP 概述"></a>HTTP 概述</h1><h2 id="u8D44_u6E90"><a href="#u8D44_u6E90" class="headerlink" title="资源"></a>资源</h2><h3 id="u5A92_u4F53_u7C7B_u578B"><a href="#u5A92_u4F53_u7C7B_u578B" class="headerlink" title="媒体类型"></a>媒体类型</h3><ol>
<li>HTML:text/html</li>
<li>ASCII:text/plain</li>
<li>JPEG:image/jpeg</li>
<li>GIF:image/gif</li>
<li>QuickTime:video/quicktime</li>
<li>PowerPoint:application/vnd.ms-powerpoint</li>
</ol>
<h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>Uniform Resource Identifier 统一资源标记符<br><a id="more"></a></p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>统一资源定位符（URL）是资源标识符最常见的形式。URL 描述了一台特定服务器<br>上某资源的特定位置。<br>URL遵循的标准格式：</p>
<ul>
<li>URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这<br>部分通常就是HTTP 协议（<a href="http://）。" target="_blank" rel="external">http://）。</a></li>
<li>第二部分给出了服务器的因特网地址（比如，www.joes-hardware.com）。</li>
<li>其余部分指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif）</li>
</ul>
<h3 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h3><p>URI 的第二种形式就是统一资源名（URN）。URN 是作为特定内容的唯一名称使用<br>的，与目前的资源所在地无关。</p>
<h2 id="u4E8B_u52A1"><a href="#u4E8B_u52A1" class="headerlink" title="事务"></a>事务</h2><p>一个HTTP 事务由一条（从客户端发往服务器的）请求命令和一个（从服务器<br>发回客户端的）响应结果组成。</p>
<h3 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th>HTTP方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>从服务器向客户端发送命名资源</td>
</tr>
<tr>
<td>PUT</td>
<td>将来自客户端的数据存储到一个命名的服务器资源中去</td>
</tr>
<tr>
<td>DELETE</td>
<td>将服务器中删除命名资源</td>
</tr>
<tr>
<td>POST</td>
<td>将客户端数据发送到一个服务器网关应用程序</td>
</tr>
<tr>
<td>HEAD</td>
<td>将发送命名资源响应中的HTTP首部</td>
</tr>
</tbody>
</table>
<h3 id="u72B6_u6001_u7801"><a href="#u72B6_u6001_u7801" class="headerlink" title="状态码"></a>状态码</h3><p>每条HTTP 响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，<br>告知客户端请求是否成功，或者是否需要采取其他动作。</p>
<h3 id="Web_u9875_u9762_u4E2D_u53EF_u4EE5_u5305_u542B_u591A_u4E2A_u5BF9_u8C61"><a href="#Web_u9875_u9762_u4E2D_u53EF_u4EE5_u5305_u542B_u591A_u4E2A_u5BF9_u8C61" class="headerlink" title="Web页面中可以包含多个对象"></a>Web页面中可以包含多个对象</h3><h2 id="u62A5_u6587"><a href="#u62A5_u6587" class="headerlink" title="报文"></a>报文</h2><ul>
<li>从Web 客户端发往Web 服务器的HTTP 报文称为请求报文（request message）</li>
<li>从服务器发往客户端的报文称为响应报文（response message）<br>HTTP报文包括三部分：</li>
</ul>
<ol>
<li>起始行<br> 报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说<br>明出现了什么情况。</li>
<li>首部字段<br> 起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为<br>了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。</li>
<li>主体<br> 空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括<br>了要发送给Web 服务器的数据；响应主体中装载了要返回给客户端的数据。</li>
</ol>
<p>简单的报文实例：<br>    <img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter1%2FsimpleHttpRequestDemo.png" alt="http://www.joes-hardware.com/tools.html 的GET 事务实例" title="http://www.joes-hardware.com/tools.html 的GET 事务实例"></p>
<h2 id="u8FDE_u63A5"><a href="#u8FDE_u63A5" class="headerlink" title="连接"></a>连接</h2><h3 id="TCP/IP"><a href="#TCP/IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节；它把联网的细节都<br>交给了通用、可靠的因特网传输协议TCP/IP。<br>TCP:</p>
<ul>
<li>无差错的数据传输</li>
<li>按序传输（数据综述会按照发送的顺序到达）</li>
<li>未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）<br>HTTP 协议位于TCP 的上层。HTTP 使用TCP 来传输其报文数<br>据。与之类似，TCP 则位于IP 的上层</li>
</ul>
<h3 id="u8FDE_u63A5_u3001IP_u5730_u5740_u53CA_u7AEF_u53E3_u53F7"><a href="#u8FDE_u63A5_u3001IP_u5730_u5740_u53CA_u7AEF_u53E3_u53F7" class="headerlink" title="连接、IP地址及端口号"></a>连接、IP地址及端口号</h3><p>在HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP）<br>地址和端口号在客户端和服务器之间建立一条TCP/IP 连接。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter1%2FconnectionProcess.png" alt="基本的浏览器连接处理" title="基本的浏览器连接处理"><br>浏览器连接处理步骤：</p>
<ol>
<li>浏览器从URL中解析出服务器的主机名</li>
<li>浏览器将服务器的主机名转换成服务器的IP地址</li>
<li>浏览器将端口号（如果有的话）从URL中解析出来</li>
<li>浏览器建立一条与Web服务器的TCP连接</li>
<li>浏览器向服务器发送一条HTTP请求报文</li>
<li>服务器向浏览器回送一条HTTP相应报文</li>
<li>关闭连接，浏览器显示文档</li>
</ol>
<h3 id="u4F7F_u7528Telnet_u5B9E_u4F8B"><a href="#u4F7F_u7528Telnet_u5B9E_u4F8B" class="headerlink" title="使用Telnet实例"></a>使用Telnet实例</h3><p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter1%2FtelnetHttpRequest.png" alt="使用Telnet的HTTP事务" title="使用Telnet的HTTP事务"></p>
<h2 id="u534F_u8BAE_u7248_u672C"><a href="#u534F_u8BAE_u7248_u672C" class="headerlink" title="协议版本"></a>协议版本</h2><ul>
<li>HTTP/0.9</li>
<li>HTTP/1.0</li>
<li>HTTP/1.0+</li>
<li>HTTP/1.1</li>
<li>HTTP-NG(又名HTTP/2.0)</li>
</ul>
<h2 id="Web_u7684_u7ED3_u6784_u7EC4_u4EF6"><a href="#Web_u7684_u7ED3_u6784_u7EC4_u4EF6" class="headerlink" title="Web的结构组件"></a>Web的结构组件</h2><p>重要的应用程序：</p>
<ul>
<li>代理<br>  位于客户端和服务器之间的HTTP中间实体</li>
<li>缓存<br>  HTTP的仓库，使常用页面的副本可以保持在离客户端更近的地方</li>
<li>网关<br>  连接其他应用程序的特殊Web服务器</li>
<li>隧道<br>  对HTTP通信报文进行盲转发的特殊代理</li>
<li>Agent代理<br>  发起自动HTTP请求的半智能Web客户端</li>
</ul>
<h3 id="u4EE3_u7406"><a href="#u4EE3_u7406" class="headerlink" title="代理"></a>代理</h3><p>代理位于客户端和服务器之间，接收所有客户端的HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter1%2FproxyConcept.png" alt="代理"></p>
<h3 id="u7F13_u5B58"><a href="#u7F13_u5B58" class="headerlink" title="缓存"></a>缓存</h3><p>Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的HTTP 代理服务<br>器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端<br>就可以享受缓存的私有副本所提供的服务了<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter1%2FcacheConcept.png" alt="缓存"></p>
<h3 id="u7F51_u5173"><a href="#u7F51_u5173" class="headerlink" title="网关"></a>网关</h3><p>网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于<br>将HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器<br>一样。客户端可能并不知道自己正在与一个网关进行通信。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter1%2FgatewayConcept.png" alt="网关"></p>
<h3 id="u96A7_u9053"><a href="#u96A7_u9053" class="headerlink" title="隧道"></a>隧道</h3><p>隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的<br>HTTP 应用程序。HTTP 隧道通常用来在一条或多条HTTP 连接上转发非HTTP 数<br>据，转发时不会窥探数据。<br>HTTP 隧道的一种常见用途是通过HTTP 连接承载加密的安全套接字层（SSL，<br>Secure Sockets Layer）流量，这样SSL 流量就可以穿过只允许Web 流量通过的防<br>火墙了。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter1%2FtunnelConcept.png" alt="隧道"></p>
<h3 id="Agent_u4EE3_u7406"><a href="#Agent_u4EE3_u7406" class="headerlink" title="Agent代理"></a>Agent代理</h3><p>用户Agent 代理（或者简称为Agent 代理）是代表用户发起HTTP 请求的客户端程<br>序。所有发布Web 请求的应用程序都是HTTP Agent 代理。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter1%2FagentConcept.png" alt="Agent代理"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="HTTP__u6982_u8FF0"><a href="#HTTP__u6982_u8FF0" class="headerlink" title="HTTP 概述"></a>HTTP 概述</h1><h2 id="u8D44_u6E90"><a href="#u8D44_u6E90" class="headerlink" title="资源"></a>资源</h2><h3 id="u5A92_u4F53_u7C7B_u578B"><a href="#u5A92_u4F53_u7C7B_u578B" class="headerlink" title="媒体类型"></a>媒体类型</h3><ol>
<li>HTML:text/html</li>
<li>ASCII:text/plain</li>
<li>JPEG:image/jpeg</li>
<li>GIF:image/gif</li>
<li>QuickTime:video/quicktime</li>
<li>PowerPoint:application/vnd.ms-powerpoint</li>
</ol>
<h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>Uniform Resource Identifier 统一资源标记符<br>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://bettersth.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[糗事百科Python爬虫实战]]></title>
    <link href="http://bettersth.xyz/2016/03/17/python-spider-demo-qiushibaike/"/>
    <id>http://bettersth.xyz/2016/03/17/python-spider-demo-qiushibaike/</id>
    <published>2016-03-17T08:24:53.000Z</published>
    <updated>2016-03-17T08:24:53.428Z</updated>
    <content type="html"><![CDATA[<p>最近开始学习Python爬虫，跟着<a href="http://cuiqingcai.com/990.html" title="Python爬虫实战一之爬取糗事百科段子" target="_blank" rel="external">Python爬虫实战一之爬取糗事百科段子</a>写了第一个爬虫。</p>
<p>代码保存于<a href="https://github.com/andrewsth/PythonSpiderDemo" title="Python Spider Demo" target="_blank" rel="external">Python Spider Demo</a></p>
<p>因为糗百的代码经常性会修改，导致正则表达式需要经常性更新，所以用教程里面的正则表达式爬数据的时候会出现问题，所以更新正则表达式如下：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">pattern = re.compile('<span class="tag">&lt;<span class="title">div.*?author</span> <span class="attribute">clearfix</span>"&gt;</span>.*?<span class="tag">&lt;<span class="title">a.*?</span>&lt;<span class="attribute">img.</span>*?&lt;<span class="attribute">h2</span>&gt;</span>(.*?)<span class="tag">&lt;/<span class="title">h2</span>&gt;</span>.*?<span class="tag">&lt;/<span class="title">a</span>&gt;</span>.*?<span class="tag">&lt;<span class="title">div.*?'</span> +</span><br><span class="line">                     '<span class="attribute">content</span>"&gt;</span>(.*?)<span class="comment">&lt;!--(.*?)--&gt;</span>.*?<span class="tag">&lt;/<span class="title">div</span>&gt;</span>(.*?)<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"stats.*?class="</span><span class="value">number"</span>&gt;</span>(.*?)<span class="tag">&lt;/<span class="title">i</span>&gt;</span>', re.S)</span></span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FpythonSpiderDemo%2Fqiushibaikeresult.png" alt="效果图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近开始学习Python爬虫，跟着<a href="http://cuiqingcai.com/990.html" title="Python爬虫实战一之爬取糗事百科段子" target="_blank" rel="external">Python爬虫实战一之爬取糗事百科段]]>
    </summary>
    
      <category term="Python" scheme="http://bettersth.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sublime Python PEP8 Autoformat插件]]></title>
    <link href="http://bettersth.xyz/2016/03/14/sublime-python-pep8-autoformat-plugin/"/>
    <id>http://bettersth.xyz/2016/03/14/sublime-python-pep8-autoformat-plugin/</id>
    <published>2016-03-14T09:53:52.000Z</published>
    <updated>2016-03-14T10:01:01.113Z</updated>
    <content type="html"><![CDATA[<h2 id="Python_PEP8_Autoformat"><a href="#Python_PEP8_Autoformat" class="headerlink" title="Python PEP8 Autoformat"></a>Python PEP8 Autoformat</h2><h3 id="u8FD9_u662F_u4E00_u6B3E_u57FA_u4E8EPEP-8_28Style_Guide_for_Python_Code_29__u6765_u683C_u5F0F_u5316python_u4EE3_u7801_u7684_u63D2_u4EF6"><a href="#u8FD9_u662F_u4E00_u6B3E_u57FA_u4E8EPEP-8_28Style_Guide_for_Python_Code_29__u6765_u683C_u5F0F_u5316python_u4EE3_u7801_u7684_u63D2_u4EF6" class="headerlink" title="这是一款基于PEP-8(Style Guide for Python Code) 来格式化python代码的插件."></a>这是一款基于<a href="https://www.python.org/dev/peps/pep-0008/" title="PEP-8文档" target="_blank" rel="external">PEP-8(Style Guide for Python Code)</a> 来格式化python代码的插件.</h3><p><a href="https://packagecontrol.io/packages/Python%20PEP8%20Autoformat" title="Python PEP8 Autoformat插件下载地址" target="_blank" rel="external">Python PEP8 Autoformat插件下载地址</a><br><a id="more"></a></p>
<h3 id="u5B98_u65B9_u4ECB_u7ECD_u4E863_u79CD_u5B89_u88C5_u65B9_u5F0F_uFF1A"><a href="#u5B98_u65B9_u4ECB_u7ECD_u4E863_u79CD_u5B89_u88C5_u65B9_u5F0F_uFF1A" class="headerlink" title="官方介绍了3种安装方式："></a>官方介绍了3种安装方式：</h3><ol>
<li>使用<a href="https://packagecontrol.io/" title="Sublime Package Control" target="_blank" rel="external">Sublime Package Control</a>安装<ul>
<li>使用快捷键 cmd+shift+P(windows 系统中使用 ctrl+shift+P) 输入Package Control: Install Package<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FpythonPlugins%2FpackageControlInstallPackage.png" alt="Package Control" title="Package Control"></li>
<li>查找到Python PEP8 Autoformat 并安装</li>
</ul>
</li>
<li>使用BitBucket上的mercurial(hg)库<ul>
<li>打开命令行，进入sublime存放包的文件夹,可以通过目录栏Preferences&gt;Browse Packages快速查找。</li>
<li>在命令行中输入’’’hg clone <a href="https://bitbucket.org/StephaneBunel/pythonpep8autoformat" target="_blank" rel="external">https://bitbucket.org/StephaneBunel/pythonpep8autoformat</a> ‘Python PEP8 Autoformat’’’’</li>
</ul>
</li>
<li>手动安装<ul>
<li>下载Python PEP8 Autoformat的<a href="https://bitbucket.org/StephaneBunel/pythonpep8autoformat/downloads/#tag-downloads" target="_blank" rel="external">压缩文件</a></li>
<li>在sublime存放包的文件夹,新建名为“Python PEP8 Autoformat”的文件夹</li>
<li>将压缩文件解压缩至新建文件夹中</li>
</ul>
</li>
</ol>
<h3 id="u76F8_u5173_u914D_u7F6E"><a href="#u76F8_u5173_u914D_u7F6E" class="headerlink" title="相关配置"></a>相关配置</h3><p>在Preference-&gt;Package Setting-&gt;Python PEP8 Autoformat-&gt;Setting-User中进行设置<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // autoformat code on save ?</span><br><span class="line">    <span class="string">"autoformat_on_save"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    // enable possibly unsafe changes (E226, E24, W6)</span><br><span class="line">    // aggressive level, <span class="number">0</span> <span class="keyword">to</span> disable:</span><br><span class="line">    <span class="string">"aggressive"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    // list codes <span class="keyword">for</span> fixes<span class="comment">; used by --ignore and --select</span></span><br><span class="line">    <span class="string">"list-fixes"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    // <span class="keyword">do</span> <span class="literal">not</span> fix these errors / warnings (e.g. [<span class="string">"E501"</span>, E4<span class="string">", "</span>W<span class="string">"])</span><br><span class="line">    "</span>ignore<span class="string">": [],</span><br><span class="line"></span><br><span class="line">    // select errors / warnings (e.g. ["</span>E4<span class="string">", "</span>W<span class="string">"])</span><br><span class="line">    "</span><span class="keyword">select</span><span class="string">": [],</span><br><span class="line"></span><br><span class="line">    // Maximum line length</span><br><span class="line">    "</span><span class="built_in">max</span>-line-length<span class="string">": 79</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h3><ul>
<li>GNU/Linux: ctrl+shift+r</li>
<li>OSX: ctrl+shift+r</li>
<li>Windows: ctrl+shift+r</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Python_PEP8_Autoformat"><a href="#Python_PEP8_Autoformat" class="headerlink" title="Python PEP8 Autoformat"></a>Python PEP8 Autoformat</h2><h3 id="u8FD9_u662F_u4E00_u6B3E_u57FA_u4E8EPEP-8_28Style_Guide_for_Python_Code_29__u6765_u683C_u5F0F_u5316python_u4EE3_u7801_u7684_u63D2_u4EF6"><a href="#u8FD9_u662F_u4E00_u6B3E_u57FA_u4E8EPEP-8_28Style_Guide_for_Python_Code_29__u6765_u683C_u5F0F_u5316python_u4EE3_u7801_u7684_u63D2_u4EF6" class="headerlink" title="这是一款基于PEP-8(Style Guide for Python Code) 来格式化python代码的插件."></a>这是一款基于<a href="https://www.python.org/dev/peps/pep-0008/" title="PEP-8文档">PEP-8(Style Guide for Python Code)</a> 来格式化python代码的插件.</h3><p><a href="https://packagecontrol.io/packages/Python%20PEP8%20Autoformat" title="Python PEP8 Autoformat插件下载地址">Python PEP8 Autoformat插件下载地址</a><br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://bettersth.xyz/tags/Python/"/>
    
      <category term="Sublime" scheme="http://bettersth.xyz/tags/Sublime/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发编程实战 笔记二]]></title>
    <link href="http://bettersth.xyz/2016/01/22/java-concurrency-in-practice-notes-two/"/>
    <id>http://bettersth.xyz/2016/01/22/java-concurrency-in-practice-notes-two/</id>
    <published>2016-01-22T05:59:44.000Z</published>
    <updated>2016-01-22T05:59:44.456Z</updated>
    <content type="html"><![CDATA[<h2 id="u7B2C_u4E09_u7AE0__u5BF9_u8C61_u7684_u5171_u4EAB"><a href="#u7B2C_u4E09_u7AE0__u5BF9_u8C61_u7684_u5171_u4EAB" class="headerlink" title="第三章 对象的共享"></a>第三章 对象的共享</h2><h3 id="u53EF_u89C1_u6027"><a href="#u53EF_u89C1_u6027" class="headerlink" title="可见性"></a>可见性</h3><blockquote>
<p>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整</p>
</blockquote>
<h4 id="u5931_u6548_u6570_u636E"><a href="#u5931_u6548_u6570_u636E" class="headerlink" title="失效数据"></a>失效数据</h4><ol>
<li><p>失效数据现象</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MutableInteger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程安全</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SynchronizedInteger</span> &#123;</span><br><span class="line">    @GuardedBy(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">int</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">set</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h4 id="u975E_u539F_u5B50_u768464_u4F4D_u64CD_u4F5C"><a href="#u975E_u539F_u5B50_u768464_u4F4D_u64CD_u4F5C" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h4><ol>
<li>最低安全性（out-of-thin-air safety）：当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少在这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证被称为最低安全性。</li>
<li>低安全性适用于绝大多数变量，除了非volatile类型的64位数值变量（double和long）</li>
<li>对于非volatile类型的double和long变量，JVM允许将64位的读操作或写操作分解为2个32位操作，需要用volatile声明或加锁，否则在多线程中不安全</li>
</ol>
<h4 id="u52A0_u9501_u4E0E_u53EF_u89C1_u6027"><a href="#u52A0_u9501_u4E0E_u53EF_u89C1_u6027" class="headerlink" title="加锁与可见性"></a>加锁与可见性</h4><blockquote>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性，所有执行读操作或者写操作的线程都必须在同一个锁上同步</p>
</blockquote>
<h4 id="Volatile_u53D8_u91CF"><a href="#Volatile_u53D8_u91CF" class="headerlink" title="Volatile变量"></a>Volatile变量</h4><ul>
<li>Java语言提供的一种稍弱的同步机制</li>
<li>不会将该变量上的操作与其他内存操作重排序</li>
<li>volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方</li>
<li>访问volatile变量时不会执行加锁操作，因此就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制</li>
</ul>
<p><strong> volatile变量的正确使用方式：</strong></p>
<ol>
<li>确保它们自身状态的可见性</li>
<li>确保它们所引用对象的状态的可见性</li>
<li>标识一些重要的程序生命周期事件的发生(例如初始化或关闭)</li>
</ol>
<blockquote>
<p>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性</p>
</blockquote>
<p><strong> 当且仅当满足以下所有条件时才应该使用volatile变量 </strong></p>
<ol>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中</li>
<li>在访问变量时不需要加锁</li>
</ol>
<h3 id="u53D1_u5E03_u4E0E_u9038_u51FA"><a href="#u53D1_u5E03_u4E0E_u9038_u51FA" class="headerlink" title="发布与逸出"></a>发布与逸出</h3><p><strong> 概念 </strong></p>
<ul>
<li>发布一个对象指使对象能够在当前作用域之外的代码中使用</li>
<li>当某个不应该发布的对象被发布时称为逸出</li>
</ul>
<p><strong>发布对象方法</strong></p>
<ol>
<li>将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象</li>
<li><p>发布某个对象时，可能会间接发布其他对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> UnsafeStates &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span>[] states = <span class="keyword">new</span> <span class="built_in">String</span>[]&#123;</span><br><span class="line">        <span class="string">"AK"</span>, <span class="string">"AL"</span> <span class="comment">/*...*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span>[] getStates() &#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布</p>
</li>
<li>发布一个内部的类实例</li>
</ol>
<h4 id="u5B89_u5168_u7684_u5BF9_u8C61_u6784_u9020_u8FC7_u7A0B"><a href="#u5B89_u5168_u7684_u5BF9_u8C61_u6784_u9020_u8FC7_u7A0B" class="headerlink" title="安全的对象构造过程"></a>安全的对象构造过程</h4><blockquote>
<p>要在构造过程中使this引用逸出,只有当构造函数返回时，this引用才应该从线程中逸出</p>
</blockquote>
<h3 id="u7EBF_u7A0B_u5C01_u95ED"><a href="#u7EBF_u7A0B_u5C01_u95ED" class="headerlink" title="线程封闭"></a>线程封闭</h3><ul>
<li>如果仅在单线程内访问数据，就不需要同步，这种技术称为线程封闭（Thread Confinement）</li>
<li>实现线程安全性的最简单方式之一</li>
</ul>
<h4 id="Ad-hoc_u7EBF_u7A0B_u5C01_u95ED_3A"><a href="#Ad-hoc_u7EBF_u7A0B_u5C01_u95ED_3A" class="headerlink" title="Ad-hoc线程封闭:"></a>Ad-hoc线程封闭:</h4><ol>
<li>维护线程封闭性的职责完全由程序实现来承担</li>
<li>Ad-hoc非常脆弱</li>
<li>尽量少用</li>
</ol>
<h4 id="u6808_u5C01_u95ED"><a href="#u6808_u5C01_u95ED" class="headerlink" title="栈封闭"></a>栈封闭</h4><ol>
<li>线程封闭的一种特例，只能通过局部变量才能访问对象</li>
<li>比Ad-hoc线程封闭更易于维护，也更加健壮</li>
<li>基本类型的局部变量始终封闭在线程内</li>
<li>在线程内部上下文中使用非线程安全的对象，那么该对象仍然是线程安全的</li>
</ol>
<h4 id="ThreadLocal_u7C7B"><a href="#ThreadLocal_u7C7B" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><ol>
<li>维持线程封闭性的更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来</li>
<li>常用于防止对可变的单实例变量或全局变量进行共享</li>
<li>线程初次调用ThreadLocal.get方法时，就调用initialValue来获取初始值</li>
<li>将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转化成ThreadLocal对象可以维持线程安全性</li>
<li>ThreadLocal变量类型全局变量，会降低代码的可重用性，并在类之间引入隐含的偶含性</li>
</ol>
<h3 id="u4E0D_u53D8_u6027"><a href="#u4E0D_u53D8_u6027" class="headerlink" title="不变性"></a>不变性</h3><blockquote>
<p>不可变对象一定是线程安全的</p>
</blockquote>
<p><strong> 满足以下条件时，对象才是不可变的：</strong></p>
<ol>
<li>对象创建以后其状态就不能修改</li>
<li>对象的所有域都是final类型</li>
<li>对象是正确创建的(在对象的创建期间，this引用没有逸出)</li>
</ol>
<h4 id="Final_u57DF"><a href="#Final_u57DF" class="headerlink" title="Final域"></a>Final域</h4><ul>
<li>final域确保初始化过程的安全性</li>
</ul>
<h4 id="u793A_u4F8B_uFF1A_u4F7F_u7528volatile_u7C7B_u578B_u6765_u53D1_u5E03_u4E0D_u53EF_u53D8_u5BF9_u8C61"><a href="#u793A_u4F8B_uFF1A_u4F7F_u7528volatile_u7C7B_u578B_u6765_u53D1_u5E03_u4E0D_u53EF_u53D8_u5BF9_u8C61" class="headerlink" title="示例：使用volatile类型来发布不可变对象"></a>示例：使用volatile类型来发布不可变对象</h4><blockquote>
<p>每当需要一堆相关数据以原子方式执行某个操作时，可以考虑创建一个不可变的类来包含这些数据</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="annotation">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span><br><span class="line">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5B89_u5168_u53D1_u5E03"><a href="#u5B89_u5168_u53D1_u5E03" class="headerlink" title="安全发布"></a>安全发布</h3><h4 id="u4E0D_u6B63_u786E_u7684_u53D1_u5E03_uFF1A_u6B63_u786E_u7684_u5BF9_u8C61_u88AB_u7834_u574F"><a href="#u4E0D_u6B63_u786E_u7684_u53D1_u5E03_uFF1A_u6B63_u786E_u7684_u5BF9_u8C61_u88AB_u7834_u574F" class="headerlink" title="不正确的发布：正确的对象被破坏"></a>不正确的发布：正确的对象被破坏</h4><h4 id="u4E0D_u53EF_u53D8_u5BF9_u8C61_u4E0E_u521D_u59CB_u5316_u5B89_u5168_u6027"><a href="#u4E0D_u53EF_u53D8_u5BF9_u8C61_u4E0E_u521D_u59CB_u5316_u5B89_u5168_u6027" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h4><blockquote>
<p>任何线程都可以在不需要额外同步的情况下安全访问不可变对象，即使在发布这些对象时没有使用同步</p>
</blockquote>
<h4 id="u5B89_u5168_u53D1_u5E03_u7684_u5E38_u7528_u6A21_u5F0F"><a href="#u5B89_u5168_u53D1_u5E03_u7684_u5E38_u7528_u6A21_u5F0F" class="headerlink" title="安全发布的常用模式"></a>安全发布的常用模式</h4><p><strong> 如何安全的发布一个对象 </strong></p>
<ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReferance对象中</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中</li>
<li>将对象的引用保存到一个由锁包含的域中</li>
</ul>
<h4 id="u4E8B_u5B9E_u4E0D_u53EF_u53D8_u5BF9_u8C61"><a href="#u4E8B_u5B9E_u4E0D_u53EF_u53D8_u5BF9_u8C61" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h4><p> 如果对象从技术上来看是可变的，但其状态在发布后不会再改吧，那么把这种对象称为“事实不可变对象”(Effectively Immutable Object)</p>
<blockquote>
<p>在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象</p>
</blockquote>
<h4 id="u53EF_u53D8_u5BF9_u8C61"><a href="#u53EF_u53D8_u5BF9_u8C61" class="headerlink" title="可变对象"></a>可变对象</h4><p> 对象在构造后可以修改，安全发布只能确保“发布当时”状态的可见性</p>
<blockquote>
<p>对象的发布需求取决于它的可变性：</p>
<ul>
<li>不可变对象可以通过任意机制来发布</li>
<li>事实不可变对象必须通过安全方式来发布</li>
<li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来</li>
</ul>
</blockquote>
<h4 id="u5B89_u5168_u7684_u5171_u4EAB_u5BF9_u8C61"><a href="#u5B89_u5168_u7684_u5171_u4EAB_u5BF9_u8C61" class="headerlink" title="安全的共享对象"></a>安全的共享对象</h4><p>在并发程序中使用和共享对象时，实用策略：<br><strong> 线程封闭 </strong> 线程封闭的对象只能由一个线程拥有，对象呗封闭在该线程中，并且只能由这个线程修改。<br><strong> 只读共享 </strong> 在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能访问它。共享的只读对象包括不可变对象和事实不可变对象。<br><strong> 线程安全共享 </strong> 线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。<br><strong> 保护对象 </strong> 被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在内部线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u7B2C_u4E09_u7AE0__u5BF9_u8C61_u7684_u5171_u4EAB"><a href="#u7B2C_u4E09_u7AE0__u5BF9_u8C61_u7684_u5171_u4EAB" class="headerlink" title="第三章 对象的共享"></a>第三章 对象的共享</h2><h3 id="u53EF_u89C1_u6027"><a href="#u53EF_u89C1_u6027" class="headerlink" title="可见性"></a>可见性</h3><blockquote>
<p>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整</p>
</blockquote>
<h4 id="u5931_u6548_u6570_u636E"><a href="#u5931_u6548_u6570_u636E" class="headerlink" title="失效数据"></a>失效数据</h4><ol>
<li><p>失效数据现象</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MutableInteger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程安全</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SynchronizedInteger</span> &#123;</span><br><span class="line">    @GuardedBy(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">int</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">set</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>]]>
    
    </summary>
    
      <category term="JCIP" scheme="http://bettersth.xyz/tags/JCIP/"/>
    
      <category term="Java" scheme="http://bettersth.xyz/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://bettersth.xyz/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo生成SiteMap]]></title>
    <link href="http://bettersth.xyz/2016/01/19/generate-site-map/"/>
    <id>http://bettersth.xyz/2016/01/19/generate-site-map/</id>
    <published>2016-01-19T07:16:17.000Z</published>
    <updated>2016-01-22T02:35:29.432Z</updated>
    <content type="html"><![CDATA[<p>今天准备配置个swiftype做个站内搜索，当搜索引擎新建成功后提示我没有找到相应的Sitemaps(站点地图)。</p>
<h1 id="u4EC0_u4E48_u662FSitemap_uFF1F"><a href="#u4EC0_u4E48_u662FSitemap_uFF1F" class="headerlink" title="什么是Sitemap？"></a>什么是Sitemap？</h1><blockquote>
<p>Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。</p>
</blockquote>
<p>Swiftype能自动抓取Sitemap对其建立索引，然后实现站内搜索。</p>
<h1 id="u5982_u4F55_u5728hexo_u4E2D_u751F_u6210Sitemap_uFF1F"><a href="#u5982_u4F55_u5728hexo_u4E2D_u751F_u6210Sitemap_uFF1F" class="headerlink" title="如何在hexo中生成Sitemap？"></a>如何在hexo中生成Sitemap？</h1><a id="more"></a>
<ol>
<li><p>安装hexo-generator-sitemap插件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure>
<p> 安装成功如下图所示：<br> <img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/generateSiteMap/generateSiteMap.png" alt="Generate Sitemap"></p>
</li>
<li><p>更新站点_config.yml文件：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># sitemap</span></span><br><span class="line"><span class="label">sitemap:</span></span><br><span class="line"><span class="label">path:</span> sitemap.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成sitemap.xml</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">hexo</span> g</span><br></pre></td></tr></table></figure>
<p>sitemap.xml生成成功：<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/generateSiteMap/generateSiteMapXML.png" alt="Generate Sitemap XML"></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天准备配置个swiftype做个站内搜索，当搜索引擎新建成功后提示我没有找到相应的Sitemaps(站点地图)。</p>
<h1 id="u4EC0_u4E48_u662FSitemap_uFF1F"><a href="#u4EC0_u4E48_u662FSitemap_uFF1F" class="headerlink" title="什么是Sitemap？"></a>什么是Sitemap？</h1><blockquote>
<p>Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。</p>
</blockquote>
<p>Swiftype能自动抓取Sitemap对其建立索引，然后实现站内搜索。</p>
<h1 id="u5982_u4F55_u5728hexo_u4E2D_u751F_u6210Sitemap_uFF1F"><a href="#u5982_u4F55_u5728hexo_u4E2D_u751F_u6210Sitemap_uFF1F" class="headerlink" title="如何在hexo中生成Sitemap？"></a>如何在hexo中生成Sitemap？</h1>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://bettersth.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发编程实战 笔记一]]></title>
    <link href="http://bettersth.xyz/2016/01/18/java-concurrency-in-practice-notes-one/"/>
    <id>http://bettersth.xyz/2016/01/18/java-concurrency-in-practice-notes-one/</id>
    <published>2016-01-18T09:38:27.000Z</published>
    <updated>2016-01-22T02:28:55.500Z</updated>
    <content type="html"><![CDATA[<h2 id="u7B2C_u4E8C_u7AE0__u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#u7B2C_u4E8C_u7AE0__u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h2><h3 id="u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="线程安全性"></a>线程安全性</h3><ol>
<li>当多个线程访问某个类时,这个类始终都能表现出正确的行为</li>
<li>无状态对象一定是线程安全的<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StatelessFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    public void service(<span class="type">ServletRequest</span> req, <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u539F_u5B50_u6027"><a href="#u539F_u5B50_u6027" class="headerlink" title="原子性"></a>原子性</h3><ol>
<li><p>竞态条件(Race Condition) </p>
<blockquote>
<p>当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件</p>
</blockquote>
<ul>
<li><strong>先检查后执行（Check-Then-Act）</strong><br>延迟性初始化<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe<span class="keyword"></span><br><span class="line">public</span> class LazyInitRace &#123;</span><br><span class="line">   <span class="keyword"> private</span> ExpensiveObject<span class="instruction"> instance </span>= null;</span><br><span class="line">   <span class="keyword"> public</span> ExpensiveObject<span class="function"> getInstance(</span><span class="function">)</span> &#123;</span><br><span class="line">       <span class="instruction"> if </span>(instance == null<span class="function">)</span></span><br><span class="line">           <span class="instruction"> instance </span>=<span class="instruction"> new </span>ExpensiveObject(<span class="function">)</span>;</span><br><span class="line">       <span class="instruction"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<ul>
<li><strong>读取-修改-写入</strong><br>递增运算<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NotThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCountingFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> long count = <span class="number">0</span>;</span><br><span class="line">    public void service(<span class="type">ServletRequest</span> req, <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">        ++count;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>复合操作</p>
<blockquote>
<p>包含了一组必须以原子方式执行的操作以确保线程安全性</p>
</blockquote>
<ul>
<li>“先检查后执行”和“读取-修改-写入”称为复合操作</li>
<li>使用现有的线程安全类来解决（java.util.concurrent.atomic 原子变量类）<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountingFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> count = <span class="keyword">new</span> <span class="type">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    public void service(<span class="type">ServletRequest</span> req, <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>在实际情况中，应尽可能地使用现有的线程安全对象（例如AtomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。</p>
</blockquote>
</li>
</ol>
<h3 id="u52A0_u9501_u673A_u5236"><a href="#u52A0_u9501_u673A_u5236" class="headerlink" title="加锁机制"></a>加锁机制</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NotThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCachingFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicReference</span>&lt;<span class="type">BigInteger</span>&gt; lastNumber</span><br><span class="line">            = <span class="keyword">new</span> <span class="type">AtomicReference</span>&lt;<span class="type">BigInteger</span>&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicReference</span>&lt;<span class="type">BigInteger</span>[]&gt; lastFactors</span><br><span class="line">            = <span class="keyword">new</span> <span class="type">AtomicReference</span>&lt;<span class="type">BigInteger</span>[]&gt;();</span><br><span class="line">    public void service(<span class="type">ServletRequest</span> req, <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber.get()))</span><br><span class="line">            encodeIntoResponse(resp, lastFactors.get());</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">            lastNumber.set(i);</span><br><span class="line">            lastFactors.set(factors);</span><br><span class="line">            encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量</p>
</blockquote>
<ol>
<li><p><strong> 内置锁：同步代码块 synchronized block </strong><br>一个作为锁的对象引用<br>一个作为由这个锁保护的代码块<br>互斥锁</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    <span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="type">BigInteger</span> lastNumber;</span><br><span class="line">    <span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="type">BigInteger</span>[] lastFactors;</span><br><span class="line">    public synchronized void service(<span class="type">ServletRequest</span> req,</span><br><span class="line">                                     <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber))</span><br><span class="line">            encodeIntoResponse(resp, lastFactors);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">            lastNumber = i;</span><br><span class="line">            lastFactors = factors;</span><br><span class="line">            encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong> 重入</strong><br>获取锁的操作粒度是“线程”不是“调用”<br>实现方法：为每个锁关联一个获取计数值和一个所有者线程<br>进一步提升了加锁行为的封装性</p>
</li>
</ol>
<h3 id="u7528_u9501_u6765_u4FDD_u62A4_u72B6_u6001"><a href="#u7528_u9501_u6765_u4FDD_u62A4_u72B6_u6001" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h3><ol>
<li>对于可能被多个线程同时访问的可变状态变量,在访问它的时候都需要持有同一个锁,则称状态变量是由这个锁保护的</li>
<li>每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁</li>
<li>对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护</li>
</ol>
<h3 id="u6D3B_u8DC3_u6027_u4E0E_u6027_u80FD"><a href="#u6D3B_u8DC3_u6027_u4E0E_u6027_u80FD" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h3><p>在简单与性能之间寻求合理的平衡</p>
<blockquote>
<p>对执行时间较长的计算或无法快速完成的操作(网络I/O、控制台I/O) 一定不要持有锁</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u7B2C_u4E8C_u7AE0__u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#u7B2C_u4E8C_u7AE0__u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h2><h3 id="u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="线程安全性"></a>线程安全性</h3><ol>
<li>当多个线程访问某个类时,这个类始终都能表现出正确的行为</li>
<li>无状态对象一定是线程安全的<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StatelessFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    public void service(<span class="type">ServletRequest</span> req, <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u539F_u5B50_u6027"><a href="#u539F_u5B50_u6027" class="headerlink" title="原子性"></a>原子性</h3><ol>
<li><p>竞态条件(Race Condition) </p>
<blockquote>
<p>当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件</p>
</blockquote>
<ul>
<li><strong>先检查后执行（Check-Then-Act）</strong><br>延迟性初始化<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe<span class="keyword"></span><br><span class="line">public</span> class LazyInitRace &#123;</span><br><span class="line">   <span class="keyword"> private</span> ExpensiveObject<span class="instruction"> instance </span>= null;</span><br><span class="line">   <span class="keyword"> public</span> ExpensiveObject<span class="function"> getInstance(</span><span class="function">)</span> &#123;</span><br><span class="line">       <span class="instruction"> if </span>(instance == null<span class="function">)</span></span><br><span class="line">           <span class="instruction"> instance </span>=<span class="instruction"> new </span>ExpensiveObject(<span class="function">)</span>;</span><br><span class="line">       <span class="instruction"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>]]>
    
    </summary>
    
      <category term="JCIP" scheme="http://bettersth.xyz/tags/JCIP/"/>
    
      <category term="Java" scheme="http://bettersth.xyz/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://bettersth.xyz/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NameCheap注册商域名修改DNS地址（新版）]]></title>
    <link href="http://bettersth.xyz/2016/01/18/modify-NameCheap-DNS/"/>
    <id>http://bettersth.xyz/2016/01/18/modify-NameCheap-DNS/</id>
    <published>2016-01-18T05:53:38.000Z</published>
    <updated>2016-01-22T06:05:59.967Z</updated>
    <content type="html"><![CDATA[<p>因为域名是在NameCheap上，使用DNSPOD解析域名，自然需要做相应的配置，可是DNSPOD官方网站的文档也是旧版的，为了方便有需要的朋友，现在将新版的配置方法共享出来。<br>旧版地址：<a href="https://support.dnspod.cn/Kb/showarticle/?qtype=%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&amp;tsid=47" title="NameCheap注册商域名修改DNS地址" target="_blank" rel="external">NameCheap注册商域名修改DNS地址</a></p>
<ol>
<li>登录<a href="http:www.namecheap.com" title="NameCheap" target="_blank" rel="external">NameCheap</a></li>
<li>打开<a href="https://ap.www.namecheap.com/Domains/DomainOnly" title="域名管理列表" target="_blank" rel="external">域名管理列表</a><br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/modifyDNS/screenshot1.png" alt="域名管理列表"><a id="more"></a></li>
<li>选择对应的域名点击点击manager进行设置</li>
<li>在Nameservers选项下选择Custom<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/modifyDNS/screenshot2.png" alt="NameServers类型选择"></li>
<li>点击Add NameServer输入dnspod的DNS短地址：<br> f1g1ns1.dnspod.net<br> f1g1ns2.dnspod.net<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/modifyDNS/screenshot3.png" alt="DNS域名管理"></li>
<li>设置完毕，等待全球递归DNS服务器刷新（最多72小时）。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为域名是在NameCheap上，使用DNSPOD解析域名，自然需要做相应的配置，可是DNSPOD官方网站的文档也是旧版的，为了方便有需要的朋友，现在将新版的配置方法共享出来。<br>旧版地址：<a href="https://support.dnspod.cn/Kb/showarticle/?qtype=%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&amp;tsid=47" title="NameCheap注册商域名修改DNS地址">NameCheap注册商域名修改DNS地址</a></p>
<ol>
<li>登录<a href="http:www.namecheap.com" title="NameCheap">NameCheap</a></li>
<li>打开<a href="https://ap.www.namecheap.com/Domains/DomainOnly" title="域名管理列表">域名管理列表</a><br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/modifyDNS/screenshot1.png" alt="域名管理列表">]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java double计算精度问题]]></title>
    <link href="http://bettersth.xyz/2015/12/29/java-double-precision/"/>
    <id>http://bettersth.xyz/2015/12/29/java-double-precision/</id>
    <published>2015-12-29T10:09:21.000Z</published>
    <updated>2016-01-22T02:29:13.540Z</updated>
    <content type="html"><![CDATA[<h1 id="java_u4E2D_u8FDB_u884Cdouble_u6570_u636E_u8BA1_u7B97_u7684_u65F6_u5019_u4F1A_u51FA_u73B0_u7CBE_u5EA6_u95EE_u9898_u3002"><a href="#java_u4E2D_u8FDB_u884Cdouble_u6570_u636E_u8BA1_u7B97_u7684_u65F6_u5019_u4F1A_u51FA_u73B0_u7CBE_u5EA6_u95EE_u9898_u3002" class="headerlink" title="java中进行double数据计算的时候会出现精度问题。"></a>java中进行double数据计算的时候会出现精度问题。</h1><h2 id="u95EE_u9898_u590D_u73B0_uFF1A"><a href="#u95EE_u9898_u590D_u73B0_uFF1A" class="headerlink" title="问题复现："></a>问题复现：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> DoublePrecision &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Double add :"</span> + (<span class="number">1.01</span> + <span class="number">2.01</span>));</span><br><span class="line">        System.out.println(<span class="string">"Double sub :"</span> + (<span class="number">2.01</span> - <span class="number">1.02</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到如下结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Double</span> <span class="tag">add</span> <span class="pseudo">:3</span><span class="class">.0199999999999996</span></span><br><span class="line"><span class="tag">Double</span> <span class="tag">sub</span> <span class="pseudo">:0</span><span class="class">.9899999999999998</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到精度出现了问题。所以对于高精度的运算double是不适合的。<br>为什么会出现精度问题可以参考这篇博文<a href="http://blog.csdn.net/abing37/article/details/5332798" title="java float double精度为什么会丢失？浅谈java的浮点数精度问题" target="_blank" rel="external">java float double精度为什么会丢失？浅谈java的浮点数精度问题</a></p>
<h2 id="u5982_u4F55_u89E3_u51B3_uFF1F"><a href="#u5982_u4F55_u89E3_u51B3_uFF1F" class="headerlink" title="如何解决？"></a>如何解决？</h2><a id="more"></a>
<p>使用BigDecimal类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> DoublePrecision &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Double add :"</span> + (<span class="number">1.01</span> + <span class="number">2.01</span>));</span><br><span class="line">        System.out.println(<span class="string">"Double sub :"</span> + (<span class="number">2.01</span> - <span class="number">1.02</span>));</span><br><span class="line">        System.out.println(<span class="string">"BigDecimal add :"</span> + BigDecimalUtil.add(<span class="number">1.01</span>, <span class="number">2.01</span>));</span><br><span class="line">        System.out.println(<span class="string">"BigDecimal sub :"</span> + BigDecimalUtil.subtract(<span class="number">2.01</span>, <span class="number">1.02</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BigDecimalUtil &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">add</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BigDecimal.valueOf(num1).add(BigDecimal.valueOf(num2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">subtract</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(Double.toString(num1)).subtract(<span class="keyword">new</span> BigDecimal(Double.toString(num2)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Double</span> <span class="tag">add</span> <span class="pseudo">:3</span><span class="class">.0199999999999996</span></span><br><span class="line"><span class="tag">Double</span> <span class="tag">sub</span> <span class="pseudo">:0</span><span class="class">.9899999999999998</span></span><br><span class="line"><span class="tag">BigDecimal</span> <span class="tag">add</span> <span class="pseudo">:3</span><span class="class">.02</span></span><br><span class="line"><span class="tag">BigDecimal</span> <span class="tag">sub</span> <span class="pseudo">:0</span><span class="class">.99</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到使用BigDecimal能够解决double计算的精度问题。</p>
<blockquote>
<p>Open Declaration BigDecimal java.math.BigDecimal.valueOf(double val)<br>Translates a double into a BigDecimal, using the double’s canonical string representation provided by the Double.toString(double) method. </p>
</blockquote>
<p>根据Java文档的介绍<code>BigDecimal.valueOf(double val)</code>与<code>new BigDecimal(Double.toString(double))</code>等价, 此处<code>add()</code>使用<code>BigDecimal.valueOf(double val)</code>,<code>subtract()</code> 使用了不同的方法<code>new BigDecimal(Double.toString(double))</code>。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>对高精度运算使用BigDecimal,尽量避免使用double计算以免精度丢失。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="java_u4E2D_u8FDB_u884Cdouble_u6570_u636E_u8BA1_u7B97_u7684_u65F6_u5019_u4F1A_u51FA_u73B0_u7CBE_u5EA6_u95EE_u9898_u3002"><a href="#java_u4E2D_u8FDB_u884Cdouble_u6570_u636E_u8BA1_u7B97_u7684_u65F6_u5019_u4F1A_u51FA_u73B0_u7CBE_u5EA6_u95EE_u9898_u3002" class="headerlink" title="java中进行double数据计算的时候会出现精度问题。"></a>java中进行double数据计算的时候会出现精度问题。</h1><h2 id="u95EE_u9898_u590D_u73B0_uFF1A"><a href="#u95EE_u9898_u590D_u73B0_uFF1A" class="headerlink" title="问题复现："></a>问题复现：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> DoublePrecision &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Double add :"</span> + (<span class="number">1.01</span> + <span class="number">2.01</span>));</span><br><span class="line">        System.out.println(<span class="string">"Double sub :"</span> + (<span class="number">2.01</span> - <span class="number">1.02</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到如下结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Double</span> <span class="tag">add</span> <span class="pseudo">:3</span><span class="class">.0199999999999996</span></span><br><span class="line"><span class="tag">Double</span> <span class="tag">sub</span> <span class="pseudo">:0</span><span class="class">.9899999999999998</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到精度出现了问题。所以对于高精度的运算double是不适合的。<br>为什么会出现精度问题可以参考这篇博文<a href="http://blog.csdn.net/abing37/article/details/5332798" title="java float double精度为什么会丢失？浅谈java的浮点数精度问题">java float double精度为什么会丢失？浅谈java的浮点数精度问题</a></p>
<h2 id="u5982_u4F55_u89E3_u51B3_uFF1F"><a href="#u5982_u4F55_u89E3_u51B3_uFF1F" class="headerlink" title="如何解决？"></a>如何解决？</h2>]]>
    
    </summary>
    
      <category term="Java" scheme="http://bettersth.xyz/tags/Java/"/>
    
  </entry>
  
</feed>
