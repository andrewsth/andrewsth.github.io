<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[BetterSTH]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://bettersth.xyz/"/>
  <updated>2016-01-19T08:00:48.701Z</updated>
  <id>http://bettersth.xyz/</id>
  
  <author>
    <name><![CDATA[sth]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Hexo生成SiteMap]]></title>
    <link href="http://bettersth.xyz/2016/01/19/generate-site-map/"/>
    <id>http://bettersth.xyz/2016/01/19/generate-site-map/</id>
    <published>2016-01-19T07:16:17.000Z</published>
    <updated>2016-01-19T08:00:48.701Z</updated>
    <content type="html"><![CDATA[<p>今天准备配置个swiftype做个站内搜索，当搜索引擎新建成功后提示我没有找到相应的Sitemaps(站点地图)。</p>
<h1 id="u4EC0_u4E48_u662FSitemap_uFF1F"><a href="#u4EC0_u4E48_u662FSitemap_uFF1F" class="headerlink" title="什么是Sitemap？"></a>什么是Sitemap？</h1><blockquote>
<p>Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。</p>
</blockquote>
<p>Swiftype能自动抓取Sitemap对其建立索引，然后实现站内搜索。</p>
<h1 id="u5982_u4F55_u5728hexo_u4E2D_u751F_u6210Sitemap_uFF1F"><a href="#u5982_u4F55_u5728hexo_u4E2D_u751F_u6210Sitemap_uFF1F" class="headerlink" title="如何在hexo中生成Sitemap？"></a>如何在hexo中生成Sitemap？</h1><ol>
<li><p>安装hexo-generator-sitemap插件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure>
<p> 安装成功如下图所示：<br> <img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/generateSiteMap/generateSiteMap.png" alt="Generate Sitemap"></p>
</li>
<li><p>更新站点_config.yml文件：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># sitemap</span></span><br><span class="line"><span class="label">sitemap:</span></span><br><span class="line"><span class="label">path:</span> sitemap.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成sitemap.xml</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">hexo</span> g</span><br></pre></td></tr></table></figure>
<p>sitemap.xml生成成功：<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/generateSiteMap/generateSiteMapXML.png" alt="Generate Sitemap XML"></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天准备配置个swiftype做个站内搜索，当搜索引擎新建成功后提示我没有找到相应的Sitemaps(站点地图)。</p>
<h1 id="u4EC0_u4E48_u662FSitemap_uFF1F"><a href="#u4EC0_u4E48_u662FSitemap_]]>
    </summary>
    
      <category term="Hexo" scheme="http://bettersth.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发编程实战 笔记一]]></title>
    <link href="http://bettersth.xyz/2016/01/18/java-concurrency-in-practice-notes-one/"/>
    <id>http://bettersth.xyz/2016/01/18/java-concurrency-in-practice-notes-one/</id>
    <published>2016-01-18T09:38:27.000Z</published>
    <updated>2016-01-18T09:42:08.211Z</updated>
    <content type="html"><![CDATA[<h2 id="u7B2C_u4E8C_u7AE0__u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#u7B2C_u4E8C_u7AE0__u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h2><h3 id="u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="线程安全性"></a>线程安全性</h3><ol>
<li>当多个线程访问某个类时,这个类始终都能表现出正确的行为</li>
<li>无状态对象一定是线程安全的<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StatelessFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    public void service(<span class="type">ServletRequest</span> req, <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u539F_u5B50_u6027"><a href="#u539F_u5B50_u6027" class="headerlink" title="原子性"></a>原子性</h3><ol>
<li><p>竞态条件(Race Condition) </p>
<blockquote>
<p>当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件</p>
</blockquote>
<ul>
<li><p><strong>先检查后执行（Check-Then-Act）</strong><br>延迟性初始化</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe<span class="keyword"></span><br><span class="line">public</span> class LazyInitRace &#123;</span><br><span class="line">   <span class="keyword"> private</span> ExpensiveObject<span class="instruction"> instance </span>= null;</span><br><span class="line">   <span class="keyword"> public</span> ExpensiveObject<span class="function"> getInstance(</span><span class="function">)</span> &#123;</span><br><span class="line">       <span class="instruction"> if </span>(instance == null<span class="function">)</span></span><br><span class="line">           <span class="instruction"> instance </span>=<span class="instruction"> new </span>ExpensiveObject(<span class="function">)</span>;</span><br><span class="line">       <span class="instruction"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>读取-修改-写入</strong><br>递增运算</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NotThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCountingFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> long count = <span class="number">0</span>;</span><br><span class="line">    public void service(<span class="type">ServletRequest</span> req, <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">        ++count;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>复合操作</p>
<blockquote>
<p>包含了一组必须以原子方式执行的操作以确保线程安全性</p>
</blockquote>
<ul>
<li>“先检查后执行”和“读取-修改-写入”称为复合操作</li>
<li>使用现有的线程安全类来解决（java.util.concurrent.atomic 原子变量类）<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountingFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> count = <span class="keyword">new</span> <span class="type">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    public void service(<span class="type">ServletRequest</span> req, <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>在实际情况中，应尽可能地使用现有的线程安全对象（例如AtomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。</p>
</blockquote>
</li>
</ol>
<h3 id="u52A0_u9501_u673A_u5236"><a href="#u52A0_u9501_u673A_u5236" class="headerlink" title="加锁机制"></a>加锁机制</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NotThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCachingFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicReference</span>&lt;<span class="type">BigInteger</span>&gt; lastNumber</span><br><span class="line">            = <span class="keyword">new</span> <span class="type">AtomicReference</span>&lt;<span class="type">BigInteger</span>&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicReference</span>&lt;<span class="type">BigInteger</span>[]&gt; lastFactors</span><br><span class="line">            = <span class="keyword">new</span> <span class="type">AtomicReference</span>&lt;<span class="type">BigInteger</span>[]&gt;();</span><br><span class="line">    public void service(<span class="type">ServletRequest</span> req, <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber.get()))</span><br><span class="line">            encodeIntoResponse(resp, lastFactors.get());</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">            lastNumber.set(i);</span><br><span class="line">            lastFactors.set(factors);</span><br><span class="line">            encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量</p>
</blockquote>
<ol>
<li><p><strong> 内置锁：同步代码块 synchronized block </strong><br>一个作为锁的对象引用<br>一个作为由这个锁保护的代码块<br>互斥锁</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ThreadSafe</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedFactorizer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GenericServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> &#123;</span></span><br><span class="line">    <span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="type">BigInteger</span> lastNumber;</span><br><span class="line">    <span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="type">BigInteger</span>[] lastFactors;</span><br><span class="line">    public synchronized void service(<span class="type">ServletRequest</span> req,</span><br><span class="line">                                     <span class="type">ServletResponse</span> resp) &#123;</span><br><span class="line">        <span class="type">BigInteger</span> i = extractFromRequest(req);</span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber))</span><br><span class="line">            encodeIntoResponse(resp, lastFactors);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BigInteger</span>[] factors = factor(i);</span><br><span class="line">            lastNumber = i;</span><br><span class="line">            lastFactors = factors;</span><br><span class="line">            encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong> 重入</strong><br>获取锁的操作粒度是“线程”不是“调用”<br>实现方法：为每个锁关联一个获取计数值和一个所有者线程<br>进一步提升了加锁行为的封装性</p>
</li>
</ol>
<h3 id="u7528_u9501_u6765_u4FDD_u62A4_u72B6_u6001"><a href="#u7528_u9501_u6765_u4FDD_u62A4_u72B6_u6001" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h3><ol>
<li>对于可能被多个线程同时访问的可变状态变量,在访问它的时候都需要持有同一个锁,则称状态变量是由这个锁保护的</li>
<li>每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁</li>
<li>对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护</li>
</ol>
<h3 id="u6D3B_u8DC3_u6027_u4E0E_u6027_u80FD"><a href="#u6D3B_u8DC3_u6027_u4E0E_u6027_u80FD" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h3><p>在简单与性能之间寻求合理的平衡</p>
<blockquote>
<p>对执行时间较长的计算或无法快速完成的操作(网络I/O、控制台I/O) 一定不要持有锁</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u7B2C_u4E8C_u7AE0__u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#u7B2C_u4E8C_u7AE0__u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" tit]]>
    </summary>
    
      <category term="JCIP" scheme="http://bettersth.xyz/tags/JCIP/"/>
    
      <category term="Java" scheme="http://bettersth.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NameCheap注册商域名修改DNS地址（新版）]]></title>
    <link href="http://bettersth.xyz/2016/01/18/modify-NameCheap-DNS/"/>
    <id>http://bettersth.xyz/2016/01/18/modify-NameCheap-DNS/</id>
    <published>2016-01-18T05:53:38.000Z</published>
    <updated>2016-01-18T05:53:38.217Z</updated>
    <content type="html"><![CDATA[<p>因为域名是在NameCheap上，使用DNSPOD解析域名，自然需要做相应的配置，可是DNSPOD官方网站的文档也是旧版的，为了方便有需要的朋友，现在将新版的配置方法共享出来。<br>旧版地址：<a href="https://support.dnspod.cn/Kb/showarticle/?qtype=%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&amp;tsid=47" title="NameCheap注册商域名修改DNS地址" target="_blank" rel="external">NameCheap注册商域名修改DNS地址</a></p>
<ol>
<li>登录<a href="http:www.namecheap.com" title="NameCheap" target="_blank" rel="external">NameCheap</a></li>
<li>打开<a href="https://ap.www.namecheap.com/Domains/DomainOnly" title="域名管理列表" target="_blank" rel="external">域名管理列表</a><br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/modifyDNS/screenshot1.png" alt="域名管理列表"></li>
<li>选择对应的域名点击点击manager进行设置</li>
<li>在Nameservers选项下选择Custom<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/modifyDNS/screenshot2.png" alt="NameServers类型选择"></li>
<li>点击Add NameServer输入dnspod的DNS短地址：<br> f1g1ns1.dnspod.net<br> f1g1ns2.dnspod.net<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog/modifyDNS/screenshot3.png" alt="DNS域名管理"></li>
<li>设置完毕，等待全球递归DNS服务器刷新（最多72小时）。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为域名是在NameCheap上，使用DNSPOD解析域名，自然需要做相应的配置，可是DNSPOD官方网站的文档也是旧版的，为了方便有需要的朋友，现在将新版的配置方法共享出来。<br>旧版地址：<a href="https://support.dnspod.cn/Kb/sh]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java double计算精度问题]]></title>
    <link href="http://bettersth.xyz/2015/12/29/java-double-precision/"/>
    <id>http://bettersth.xyz/2015/12/29/java-double-precision/</id>
    <published>2015-12-29T10:09:21.000Z</published>
    <updated>2016-01-18T06:37:57.624Z</updated>
    <content type="html"><![CDATA[<h1 id="java_u4E2D_u8FDB_u884Cdouble_u6570_u636E_u8BA1_u7B97_u7684_u65F6_u5019_u4F1A_u51FA_u73B0_u7CBE_u5EA6_u95EE_u9898_u3002"><a href="#java_u4E2D_u8FDB_u884Cdouble_u6570_u636E_u8BA1_u7B97_u7684_u65F6_u5019_u4F1A_u51FA_u73B0_u7CBE_u5EA6_u95EE_u9898_u3002" class="headerlink" title="java中进行double数据计算的时候会出现精度问题。"></a>java中进行double数据计算的时候会出现精度问题。</h1><h2 id="u95EE_u9898_u590D_u73B0_uFF1A"><a href="#u95EE_u9898_u590D_u73B0_uFF1A" class="headerlink" title="问题复现："></a>问题复现：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> DoublePrecision &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Double add :"</span> + (<span class="number">1.01</span> + <span class="number">2.01</span>));</span><br><span class="line">        System.out.println(<span class="string">"Double sub :"</span> + (<span class="number">2.01</span> - <span class="number">1.02</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到如下结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Double</span> <span class="tag">add</span> <span class="pseudo">:3</span><span class="class">.0199999999999996</span></span><br><span class="line"><span class="tag">Double</span> <span class="tag">sub</span> <span class="pseudo">:0</span><span class="class">.9899999999999998</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到精度出现了问题。所以对于高精度的运算double是不适合的。<br>为什么会出现精度问题可以参考这篇博文<a href="http://blog.csdn.net/abing37/article/details/5332798" title="java float double精度为什么会丢失？浅谈java的浮点数精度问题" target="_blank" rel="external">java float double精度为什么会丢失？浅谈java的浮点数精度问题</a></p>
<h2 id="u5982_u4F55_u89E3_u51B3_uFF1F"><a href="#u5982_u4F55_u89E3_u51B3_uFF1F" class="headerlink" title="如何解决？"></a>如何解决？</h2><p>使用BigDecimal类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> DoublePrecision &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Double add :"</span> + (<span class="number">1.01</span> + <span class="number">2.01</span>));</span><br><span class="line">        System.out.println(<span class="string">"Double sub :"</span> + (<span class="number">2.01</span> - <span class="number">1.02</span>));</span><br><span class="line">        System.out.println(<span class="string">"BigDecimal add :"</span> + BigDecimalUtil.add(<span class="number">1.01</span>, <span class="number">2.01</span>));</span><br><span class="line">        System.out.println(<span class="string">"BigDecimal sub :"</span> + BigDecimalUtil.subtract(<span class="number">2.01</span>, <span class="number">1.02</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BigDecimalUtil &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">add</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BigDecimal.valueOf(num1).add(BigDecimal.valueOf(num2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">subtract</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(Double.toString(num1)).subtract(<span class="keyword">new</span> BigDecimal(Double.toString(num2)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Double</span> <span class="tag">add</span> <span class="pseudo">:3</span><span class="class">.0199999999999996</span></span><br><span class="line"><span class="tag">Double</span> <span class="tag">sub</span> <span class="pseudo">:0</span><span class="class">.9899999999999998</span></span><br><span class="line"><span class="tag">BigDecimal</span> <span class="tag">add</span> <span class="pseudo">:3</span><span class="class">.02</span></span><br><span class="line"><span class="tag">BigDecimal</span> <span class="tag">sub</span> <span class="pseudo">:0</span><span class="class">.99</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到使用BigDecimal能够解决double计算的精度问题。</p>
<blockquote>
<p>Open Declaration BigDecimal java.math.BigDecimal.valueOf(double val)<br>Translates a double into a BigDecimal, using the double’s canonical string representation provided by the Double.toString(double) method. </p>
</blockquote>
<p>根据Java文档的介绍<code>BigDecimal.valueOf(double val)</code>与<code>new BigDecimal(Double.toString(double))</code>等价, 此处<code>add()</code>使用<code>BigDecimal.valueOf(double val)</code>,<code>subtract()</code> 使用了不同的方法<code>new BigDecimal(Double.toString(double))</code>。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>对高精度运算使用BigDecimal,尽量避免使用double计算以免精度丢失。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="java_u4E2D_u8FDB_u884Cdouble_u6570_u636E_u8BA1_u7B97_u7684_u65F6_u5019_u4F1A_u51FA_u73B0_u7CBE_u5EA6_u95EE_u9898_u3002"><a href="#ja]]>
    </summary>
    
      <category term="Java" scheme="http://bettersth.xyz/tags/Java/"/>
    
  </entry>
  
</feed>
