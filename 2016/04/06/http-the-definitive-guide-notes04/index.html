<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="HTTP," />





  <link rel="alternate" href="/atom.xml" title="BetterSTH" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="连接管理TCP连接http://www.joes-hardware.com:80/power-tools.html">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP权威指南 笔记四">
<meta property="og:url" content="http://bettersth.xyz/2016/04/06/http-the-definitive-guide-notes04/index.html">
<meta property="og:site_name" content="BetterSTH">
<meta property="og:description" content="连接管理TCP连接http://www.joes-hardware.com:80/power-tools.html">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTCPConnection.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTCPTransfer.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpAndhttps.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTcpIPTransfer.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpFourDifferentTcps.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FTCPAPI.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTransactionProcess.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.2.3pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.3.1pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.3.1pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.4.0pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.4.1pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.2pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.3pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.6pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.7pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.7pic02.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.6.0pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.7.4pic01.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.7.4pic02.png">
<meta property="og:image" content="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.7.4pic03.png">
<meta property="og:updated_time" content="2016-04-06T09:49:27.315Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HTTP权威指南 笔记四">
<meta name="twitter:description" content="连接管理TCP连接http://www.joes-hardware.com:80/power-tools.html">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: "post",
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> HTTP权威指南 笔记四 | BetterSTH </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d1eb7899798e600b673a7af153ac3f69";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  

  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">BetterSTH</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'to8ChRfJZyanZLDn-5zq','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                HTTP权威指南 笔记四
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-06T17:49:27+08:00" content="2016-04-06">
              2016-04-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/06/http-the-definitive-guide-notes04/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/06/http-the-definitive-guide-notes04/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="u8FDE_u63A5_u7BA1_u7406"><a href="#u8FDE_u63A5_u7BA1_u7406" class="headerlink" title="连接管理"></a>连接管理</h1><h2 id="TCP_u8FDE_u63A5"><a href="#TCP_u8FDE_u63A5" class="headerlink" title="TCP连接"></a>TCP连接</h2><p><a href="http://www.joes-hardware.com:80/power-tools.html" target="_blank" rel="external">http://www.joes-hardware.com:80/power-tools.html</a><br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTCPConnection.png" alt="Web浏览器通过TCP连接与Web服务器进行交互"></p>
<a id="more"></a>
<ul>
<li>第1-3步将服务器的IP地址和端口号从URL中分离出来</li>
<li>第4步中建立到Web服务器的TCP连接</li>
<li>在第5步通过这条连接发送一条请求报文</li>
<li>在第6步读取响应</li>
<li>在第7步关闭连接</li>
</ul>
<h3 id="TCP_u53EF_u9760_u6570_u636E_u7BA1_u9053"><a href="#TCP_u53EF_u9760_u6570_u636E_u7BA1_u9053" class="headerlink" title="TCP可靠数据管道"></a>TCP可靠数据管道</h3><p>TCP为HTTP提供一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序、正确地传送出来</p>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTCPTransfer.png" alt="TCP会按序、无差错地承载HTTP数据"></p>
<h3 id="TCP_u6D41_u662F_u5206_u6BB5_u7684_u3001_u7531IP_u5206_u7EC4_u4F20_u9001"><a href="#TCP_u6D41_u662F_u5206_u6BB5_u7684_u3001_u7531IP_u5206_u7EC4_u4F20_u9001" class="headerlink" title="TCP流是分段的、由IP分组传送"></a>TCP流是分段的、由IP分组传送</h3><p>TCP的数据是通过名为IP分组（或IP数据报）的小数据块来发送的。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpAndhttps.png" alt="HTTP和HTTPS网络协议栈"></p>
<p>HTTP就是“HTTP over TCP over IP”这个“协议栈”中的最顶层。<br>其安全版本HTTPS就是在HTTP和TCP之间插入了一个（称为TLS或SSL的）密码加密层。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTcpIPTransfer.png" alt="Tcp/IP传输"></p>
<p>HTTP要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输。TCP收到数据流后，会将数据流砍成被称作段的小数据块，并将段封装在IP分组中，通过因特网进行传输。<br>每个TCP段都是由IP分组承载，从一个IP地址发送到另一个IP地址。<br>IP地址包括：</p>
<ul>
<li>一个IP分组首部（通常为20字节）</li>
<li>一个TCP段首部（通常为20字节）</li>
<li>一个TCP数据块（0个或多个字节）</li>
</ul>
<p>IP首部包含了源和目的IP地址、长度和其他一些标记。<br>TCP段的首部包含了TCP端口号、TCP控制标记，以及用于数据排序和完整性检查的一些数字值。</p>
<h3 id="u4FDD_u6301TCP_u8FDE_u63A5_u7684_u6B63_u786E_u8FD0_u884C"><a href="#u4FDD_u6301TCP_u8FDE_u63A5_u7684_u6B63_u786E_u8FD0_u884C" class="headerlink" title="保持TCP连接的正确运行"></a>保持TCP连接的正确运行</h3><p>TCP是通过端口号来保持所有这些连接的正确运行的。<br>IP地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序。<br>TCP连接是通过 4个值来识别的的：<code>&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt;</code><br>这4个值一起唯一地定义了一条连接。两条不同的TCP连接不能拥有4个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）</p>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpFourDifferentTcps.png" alt="4个不同的TCP连接"></p>
<p>图中4条连接每个端口的相关信息：</p>
<table>
<thead>
<tr>
<th style="text-align:center">连接</th>
<th style="text-align:center">源IP地址</th>
<th style="text-align:center">源端口</th>
<th style="text-align:center">目的IP地址</th>
<th style="text-align:center">目的端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">209.1.32.34</td>
<td style="text-align:center">2034</td>
<td style="text-align:center">204.62.128.58</td>
<td style="text-align:center">4133</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">209.1.32.35</td>
<td style="text-align:center">3227</td>
<td style="text-align:center">204.62.128.58</td>
<td style="text-align:center">4140</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">209.1.32.35</td>
<td style="text-align:center">3105</td>
<td style="text-align:center">207.25.71.25</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">209.1.33.89</td>
<td style="text-align:center">5100</td>
<td style="text-align:center">207.25.71.25</td>
<td style="text-align:center">80</td>
</tr>
</tbody>
</table>
<h3 id="u7528TCP_u5957_u63A5_u5B57_u7F16_u7A0B"><a href="#u7528TCP_u5957_u63A5_u5B57_u7F16_u7A0B" class="headerlink" title="用TCP套接字编程"></a>用TCP套接字编程</h3><p>操作系统提供了一些操纵其TCP连接的工具。<br>套接字API提供的一些主要接口</p>
<table>
<thead>
<tr>
<th style="text-align:left">套接字API调用</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">s = socket(<parameters>)</parameters></td>
<td style="text-align:left">创建一个新的、未命名、未关联的套接字</td>
</tr>
<tr>
<td style="text-align:left">bind(s,<local ip:port="">)</local></td>
<td style="text-align:left">向套接字赋一个本地端口号和接口</td>
</tr>
<tr>
<td style="text-align:left">connect(s,<remote ip:port="">)</remote></td>
<td style="text-align:left">创建一条连接本地套接字与远程主机及端口的连接</td>
</tr>
<tr>
<td style="text-align:left">listen(s,…)</td>
<td style="text-align:left">标识一个本地套接字，使其可以合法接受连接</td>
</tr>
<tr>
<td style="text-align:left">s2 = accept(s)</td>
<td style="text-align:left">等待某人建立一条到本地端口的连接</td>
</tr>
<tr>
<td style="text-align:left">n = read(s,buffer,n)</td>
<td style="text-align:left">尝试从套接字向缓冲区读取n个字节</td>
</tr>
<tr>
<td style="text-align:left">n = write(s,buffer,n)</td>
<td style="text-align:left">尝试从缓冲区中向套接字写入n个字节</td>
</tr>
<tr>
<td style="text-align:left">close(s)</td>
<td style="text-align:left">完全关闭TCP连接</td>
</tr>
<tr>
<td style="text-align:left">shutdown(s,<side>)</side></td>
<td style="text-align:left">只关闭TCP连接的输入或输出端</td>
</tr>
<tr>
<td style="text-align:left">getsockopt(s,…)</td>
<td style="text-align:left">读取某个内部套接字配置选项的值</td>
</tr>
<tr>
<td style="text-align:left">setsockopt(s,…)</td>
<td style="text-align:left">修改某个内部套接字配置选项的值</td>
</tr>
</tbody>
</table>
<p>套接字API允许用户创建TCP的端点数据结构，将这些端点与远程服务器的TCP端点进行连接，并对数据流进行读写。TCP API隐藏了所有底层网络协议的握手细节，以及TCP数据流与IP分组之间</p>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FTCPAPI.png" alt="通过TCP套接字接口进行通信"></p>
<h2 id="u5BF9TCP_u6027_u80FD_u7684_u8003_u8651"><a href="#u5BF9TCP_u6027_u80FD_u7684_u8003_u8651" class="headerlink" title="对TCP性能的考虑"></a>对TCP性能的考虑</h2><p>HTTP紧挨着TCP，位于其上层，所以HTTP事务的性能在很大程度上取决于底层TCP通道的性能。</p>
<h3 id="HTTP_u4E8B_u52A1_u7684_u65F6_u5EF6"><a href="#HTTP_u4E8B_u52A1_u7684_u65F6_u5EF6" class="headerlink" title="HTTP事务的时延"></a>HTTP事务的时延</h3><p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2FhttpTransactionProcess.png" alt="串行HTTP事务"></p>
<p>HTTP事务的时延有以下几种原因：</p>
<ol>
<li>客户端首先需要根据URI确定Web服务器的IP地址和端口号。如果最近没有对URI中的主机名进行访问，通过DNS解析系统将URI中的主机名转换成一个IP地址可能要花费数十秒的时间。</li>
<li>接下来，客户端会向服务器发送一条TCP连接请求，并等待服务器回送一个请求接受应答。每条新的TCP连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值会快速地叠加上去。</li>
<li>一旦连接建立起来了，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器会从TCP连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间。</li>
<li>然后，Web服务器会回送HTTP响应，这也需要花费时间。</li>
</ol>
<h3 id="u6027_u80FD_u805A_u7126_u533A_u57DF"><a href="#u6027_u80FD_u805A_u7126_u533A_u57DF" class="headerlink" title="性能聚焦区域"></a>性能聚焦区域</h3><p>最常见的TCP相关时延：</p>
<ul>
<li>TCP连接建立握手</li>
<li>TCP慢启动拥塞控制</li>
<li>数据聚集的Nagle算法</li>
<li>用于捎带确认的TCP延迟确认算法</li>
<li>TIME_WAIT时延和端口耗尽</li>
</ul>
<h3 id="TCP_u8FDE_u63A5_u7684_u63E1_u624B_u65F6_u5EF6"><a href="#TCP_u8FDE_u63A5_u7684_u63E1_u624B_u65F6_u5EF6" class="headerlink" title="TCP连接的握手时延"></a>TCP连接的握手时延</h3><p>建立一条新的TCP连接时，甚至是在发送任意数据之前，TCP软件之间会交换一系列的IP分组，对连接的有关参数进行沟通。如果连接只用来传送少量数据，这些交换过程就会严重降低HTTP的性能。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.2.3pic01.png" alt="TCP连接"></p>
<p>TCP连接握手3步骤</p>
<ol>
<li>请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（通常是40-60个字节）。这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求。</li>
<li>如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受。</li>
<li>最后，客户端向服务器回送一条确认信息，通知它连接已成功建立。现在的TCP栈都允许客户端在这个确认分组中发送数据。</li>
</ol>
<p>小的HTTP事务可能会在TCP建立上花费50%，或更多的时间。</p>
<h3 id="u5EF6_u8FDF_u786E_u8BA4"><a href="#u5EF6_u8FDF_u786E_u8BA4" class="headerlink" title="延迟确认"></a>延迟确认</h3><p>TCP实现了自己的确认机制来确保数据的成功传输。<br>每个TCP段都有一个序列号和数据完整性校验和。每个段的接收都收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。<br>“延时确定”算法会在一个特定的窗口时间（通常是100~200毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。<br>但HTTP具有双峰特征的请求-应答行为降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。</p>
<h3 id="TCP_u6162_u542F_u52A8"><a href="#TCP_u6162_u542F_u52A8" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h3><p><strong>TCP慢启动（slow start)</strong>:TCP连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输速度。用于防止因特网的突然过载和拥塞。<br>TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。</p>
<h3 id="Nagle_u7B97_u6CD5_u4E0ETCP_NODELAY"><a href="#Nagle_u7B97_u6CD5_u4E0ETCP_NODELAY" class="headerlink" title="Nagle算法与TCP_NODELAY"></a>Nagle算法与TCP_NODELAY</h3><p>Nagle算法试图在发送一个分组之前，将大量TCP数据绑定在一起，以提高网络效率。<br>Nagle算法鼓励发送全尺寸的段。只有当所有其他分组都被确认之后，Nagle算法才允许发送非全尺寸的分组。<br>Nagle算法可能会引发几种HTTP性能问题：</p>
<ol>
<li>小的HTTP报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据产生时延。</li>
<li>Nagle算法与延迟确认之间的交互存在问题-Nagle算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟100~200毫秒。<br>HTTP应用程序常常会在自己的栈中设置参数TCP_NODELAY，禁用Nagle算法，提高性能。</li>
</ol>
<h3 id="TIME_WAIT_u7D2F_u79EF_u4E0E_u7AEF_u53E3_u8017_u5C3D"><a href="#TIME_WAIT_u7D2F_u79EF_u4E0E_u7AEF_u53E3_u8017_u5C3D" class="headerlink" title="TIME_WAIT累积与端口耗尽"></a>TIME_WAIT累积与端口耗尽</h3><p>当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用其期的2倍（称为2MSL，通常为2分钟）左右，以确保在这段时间内不会创建两个具有相同IP地址和端口号的连接。如果连接率过高会产生TIME_WAIT端口耗尽问题。<br>即使没有端口耗尽，也要特别小心有大量连接处于打开状态的情况，或为处于等待状态的连接分配了大量控制块的情况。</p>
<h2 id="HTTP_u8FDE_u63A5_u7684_u5904_u7406"><a href="#HTTP_u8FDE_u63A5_u7684_u5904_u7406" class="headerlink" title="HTTP连接的处理"></a>HTTP连接的处理</h2><h3 id="u5E38_u88AB_u8BEF_u89E3_u7684Connection_u9996_u90E8"><a href="#u5E38_u88AB_u8BEF_u89E3_u7684Connection_u9996_u90E8" class="headerlink" title="常被误解的Connection首部"></a>常被误解的Connection首部</h3><p>Connection首部可以承载3种不同类型的标签：</p>
<ul>
<li>HTTP首部字段名，列出了只与此连接有关的首部</li>
<li>任意标签值，用于描述此连接的非标准选项</li>
<li>值close，说明操作完成之后需关闭这条持久连接</li>
</ul>
<p>如果连接标签中包含了一个HTTP首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去。在将报文转发出去之前，必须删除Connection首部列出的所有首部字段。由于Connection首部可以防止无意中对本地首部的转发，因此将逐跳首部名放入Connection首部被称为“对首部的保护”<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.3.1pic01.png" alt="Connection首部允许发送端指定与连接有关的选项"></p>
<h3 id="u4E32_u884C_u4E8B_u52A1_u5904_u7406_u65F6_u5EF6"><a href="#u4E32_u884C_u4E8B_u52A1_u5904_u7406_u65F6_u5EF6" class="headerlink" title="串行事务处理时延"></a>串行事务处理时延</h3><p>如果只对连接进行简单的管理，TCP性能时延可能会叠加起来。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.3.1pic01.png" alt="4个事务（串行）"></p>
<p>串行加载的另一个缺点是，有些浏览器在对象加载完毕之前无法获知对象的尺寸，而且它们可能需要尺寸信息来决定将对象放在屏幕的什么位置上，所以加载了足够多的对象之前，无法在屏幕上显示任何内容。在这种情况下，可能浏览器串行装载对象的进度很正常，但用户面对的却是一个空白的屏幕，对装载的进度一无所知。</p>
<p>提高HTTP的连接性能的4种技术</p>
<ol>
<li>并行连接<br> 通过多条TCP连接发起并发的HTTP请求</li>
<li>持久连接<br> 重用TCP连接，以消除连接及关闭时延</li>
<li>管道化连接<br> 通过共享的TCP连接发起并发的HTTP请求</li>
<li>复用的连接<br> 交替传送请求和响应报文（实验阶段）</li>
</ol>
<h2 id="u5E76_u884C_u8FDE_u63A5"><a href="#u5E76_u884C_u8FDE_u63A5" class="headerlink" title="并行连接"></a>并行连接</h2><p>HTTP允许客户端打开多条连接，并行地执行多个HTTP事务<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.4.0pic01.png" alt="每个组件都包含一个独立的HTTP事务"></p>
<h3 id="u5E76_u884C_u8FDE_u63A5_u53EF_u80FD_u4F1A_u63D0_u9AD8_u9875_u9762_u7684_u52A0_u8F7D_u901F_u5EA6"><a href="#u5E76_u884C_u8FDE_u63A5_u53EF_u80FD_u4F1A_u63D0_u9AD8_u9875_u9762_u7684_u52A0_u8F7D_u901F_u5EA6" class="headerlink" title="并行连接可能会提高页面的加载速度"></a>并行连接可能会提高页面的加载速度</h3><p>包含嵌入对象的组合页面如果能（通过并行连接）克服单条连接的空载时间和带宽限制，加载速度也会有所提高。时延可以重叠起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。</p>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.4.1pic01.png" alt="4个事务（并行）"></p>
<h3 id="u5E76_u884C_u8FDE_u63A5_u4E0D_u4E00_u5B9A_u66F4_u5FEB"><a href="#u5E76_u884C_u8FDE_u63A5_u4E0D_u4E00_u5B9A_u66F4_u5FEB" class="headerlink" title="并行连接不一定更快"></a>并行连接不一定更快</h3><p>客户端的网络带宽不足时，大部分的时间可能都是用来传送数据的。这种情况下，一个连接到速度较快服务器上的HTTP事务就会很容易地耗尽所有可用的带宽。如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。<br>而且打开大量连接会消耗很多内存资源，从而引发自身的性能问题。<br>实际上浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小的值（通常是4个）。服务器可以随意关闭来自特定客户端的超量连接。</p>
<h3 id="u5E76_u884C_u8FDE_u63A5_u53EF_u80FD_u8BA9_u4EBA_u201C_u611F_u89C9_u201D_u66F4_u5FEB_u4E00_u4E9B"><a href="#u5E76_u884C_u8FDE_u63A5_u53EF_u80FD_u8BA9_u4EBA_u201C_u611F_u89C9_u201D_u66F4_u5FEB_u4E00_u4E9B" class="headerlink" title="并行连接可能让人“感觉”更快一些"></a>并行连接可能让人“感觉”更快一些</h3><p>并行连接并不总是能使页面加载得更快一些，即使实际它们并没有加快页面的传输速度，并行连接通常也会让用户<strong>觉得</strong>页面加载的更快了。</p>
<h2 id="u6301_u4E45_u8FDE_u63A5"><a href="#u6301_u4E45_u8FDE_u63A5" class="headerlink" title="持久连接"></a>持久连接</h2><p>初始化了对某服务器HTTP请求的应用程序很可能会在不久的将来对那台服务器发起更多的请求。这种性质被称为<strong>站点本地性(site locality)</strong><br>HTTP/1.1允许HTTP设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。在事务处理结束后仍然保持在打开状态的TCP连接被称为<strong>持久连接</strong><br>非持久连接会在每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。<br>重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立过程，而且已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。</p>
<h3 id="u6301_u4E45_u4EE5_u53CA_u5E76_u884C_u8FDE_u63A5"><a href="#u6301_u4E45_u4EE5_u53CA_u5E76_u884C_u8FDE_u63A5" class="headerlink" title="持久以及并行连接"></a>持久以及并行连接</h3><p>并行连接可以提高复合页面的传输速度，但并行连接的一些缺点：</p>
<ul>
<li>每个事务都会打开/关闭一条新的连接，会耗费时间和带宽</li>
<li>由于TCP慢启动特性的存在，每条新连接的性能都会有所降低</li>
<li>可打开的并行连接数量实际上是有限的</li>
</ul>
<p>持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。<br>管理持久连接要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。<br>持久连接与并行连接配合使用可能是最高效的方式。很多Web应用程序都会打开少量的并行连接，其中的每一个都是持久连接。<br>持久连接2种类型：</p>
<ol>
<li>比较老的HTTP/1.0+”keep-alive”连接</li>
<li>现代的HTTP/1.1 “persistent”连接</li>
</ol>
<h3 id="HTTP/1-0+keep-alive_u8FDE_u63A5"><a href="#HTTP/1-0+keep-alive_u8FDE_u63A5" class="headerlink" title="HTTP/1.0+keep-alive连接"></a>HTTP/1.0+keep-alive连接</h3><p>下图显示了keep-alive连接的一些性能优点，图中将在串行连接上实现4个HTTP事务的时间线与在一条持久连接上实现同样事务所需的时间线进行了比较。由于去除了进行连接和关闭连接的开销，所以时间线有所缩减。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.2pic01.png" alt="4个事务（串行与持久连接）"></p>
<h3 id="Keep-Alive_u64CD_u4F5C"><a href="#Keep-Alive_u64CD_u4F5C" class="headerlink" title="Keep-Alive操作"></a>Keep-Alive操作</h3><p>keep-alive已经不再使用了，而且在当前的HTTP/1.1规范中也没有对它的说明了。但浏览器和服务器对keep-alive握手的使用仍然相当广泛，因此，HTTP的实现者应该做好与之进行交互操作的准备。<br>实现HTTP/1.0 keep-alive连接的客户端可以通过包含Connection: Keep-Alive首部请求将一条连接保持在打开状态。<br>如果服务器愿意为下一条请求连接保持在打开状态，就在响应中包含相同的首部。如果响应中没有Connection: Keep-Alive首部，客户端就认为服务器不支持keep-alive，会在发回响应报文之后关闭连接。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.3pic01.png" alt="HTTP/1.0 keep-alive事务首部的握手过程"></p>
<h3 id="Keep-Alive_u9009_u9879"><a href="#Keep-Alive_u9009_u9879" class="headerlink" title="Keep-Alive选项"></a>Keep-Alive选项</h3><p> keep-alive首部只是请求将连接保持在活跃状态。发出keep-alive请求之后，客户端和服务器并不一定会同意进行keep-alive会话。它们可以在任意时刻关闭空闲的keep-alive连接，并可随意限制keep-alive连接所处理事务的数量。<br> 可以用Keep-Alive通用首部中指定、由逗号分隔的选项来调节keep-alive的行为。</p>
<ul>
<li>参数timeout是在Keep-Alive响应首部发送。它估计了服务器希望将连接保持在活跃状态的时间。这并不是一个承诺值。</li>
<li>参数max是在Keep-Alive响应首部发送的。它估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值。</li>
<li>Keep-Alive首部还支持任意未经处理的属性，这些属性主要用于诊断和调试。语法为name[=value]。<br>Keep-Alive首部完全是可选的，但只有在提供Connection: Keep-Alive时才能使用它。<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span>: <span class="string">Keep-Alive</span></span><br><span class="line"><span class="attribute">Keep-Alive</span>: <span class="string">max=5, timeout=120</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Keep-Alive_u8FDE_u63A5_u7684_u9650_u5236_u548C_u89C4_u5219"><a href="#Keep-Alive_u8FDE_u63A5_u7684_u9650_u5236_u548C_u89C4_u5219" class="headerlink" title="Keep-Alive连接的限制和规则"></a>Keep-Alive连接的限制和规则</h3><p>使用keep-alive连接时的一些限制：</p>
<ul>
<li>在HTTP/1.0中，keep-alive并不是默认使用的。客户端必须发送一个Connection:Keep-Alive请求首部来激活keep-alive连接。</li>
<li>Connection:Keep-Alive首部必须随所有希望保持持久连接的报文一起发送。</li>
<li>客户端探明响应中没有Connection:Keep-Alive响应首部，就可以知道服务器发出响应之后是否会关闭连接了。</li>
<li>只有在无需检测到连接的关闭即可确定实体主体部分长度的情况下，才能将连接保持在打开状态–也就是说实体的主体部分必须有正确的Content-Length，有多部件媒体类型，或者用分块传输编码的方式进行了编码。</li>
<li>代理和网关必须执行Connection首部的规则。代理或网关必须在将报文转发出去或将其高速缓存之前，删除在Connection首部中命名的所有首部字段以及Connection首部自身。</li>
<li>严格来说，不应该与无法确定是否支持Connection首部的代理服务器建立keep-alive连接，以防止出现哑代理问题。在实际应用中不是总能做到这一点的。</li>
<li>从技术上来讲，应该忽略所有来自HTTP/1.0设备的Connection首部字段（包括Connection:Keep-Alive),因为它们可能是由比较老的代理服务器误转发的。</li>
<li>除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之前连接就关闭了，客户端就一定要做好重试请求的准备。</li>
</ul>
<h3 id="Keep-Alive_u548C_u54D1_u4EE3_u7406"><a href="#Keep-Alive_u548C_u54D1_u4EE3_u7406" class="headerlink" title="Keep-Alive和哑代理"></a>Keep-Alive和哑代理</h3><h4 id="Connection_u9996_u90E8_u548C_u76F2_u4E2D_u7EE7"><a href="#Connection_u9996_u90E8_u548C_u76F2_u4E2D_u7EE7" class="headerlink" title="Connection首部和盲中继"></a>Connection首部和盲中继</h4><p> <strong>盲中继</strong>它们只是将字节从一个连接转发到另一个连接中去，不对Connection首部进行特殊的处理。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.6pic01.png" alt="keep-alive无法与不支持Connection首部的代理进行互操作"></p>
<ol>
<li>Web客户端向代理发送了一条报文，其中包含了Connection:Keep-Alive首部，如果可能的话请求建立一条keep-alive连接。客户端等待响应，以确定对方是否认可它对keep-alive信道的请求。</li>
<li>哑代理收到了这条HTTP请求，但它并不理解Connection首部（只是将其作为一个扩展首部对待）。代理不知道keep-alive是什么意思，因此只是沿着转发链路将报文一字不漏地发送给服务器。但Connection首部是个逐跳首部，只适用于单条传输链路，不应该沿着传输链路向下传输。</li>
<li>经过中继HTTP请求抵达了Web服务器。当服务器收到经过代理转发的Connection:Keep-Alive首部时，会误以为代理（对服务器来说，这个代理看起来就和所有其他客户端一样）希望进行keep-alive对话！对Web服务器来说这没什么问题–它同意进行keep-alive对话，并回送了一个Connection:Keep-Alive响应首部。所以，此时服务器认为它在与代理进行keep-alive对话，会遵循keep-alive的规则。但代理却对keep-alive一无所知。</li>
<li>哑代理将Web服务器的响应报文回送给客户端，并将来自Web服务器的Connection:Keep-Alive首部一起传送过去。客户端看到这个首部，就会认为代理同意进行keep-alive对话。所以此时客户端和服务器都认为它们在进行keep-alive对话，但与它们进行对话的代理却对keep-alive一无所知。</li>
<li>由于代理对keep-alive一无所知，所以会将收到的所有数据都回送给客户端，然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了，所以不会去关闭连接。这样代理就会挂在那里等待连接的关闭。</li>
<li>客户端在收到回送的响应报文时，会立即转向下一条请求，在keep-alive连接上向代理发送另一条请求。而代理并不认为同一条连接上会有其他请求到来，请求被忽略，浏览器就在这里转圈，不会有任何进展了。</li>
<li>这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接超时，并将其关闭为止。</li>
</ol>
<h4 id="u4EE3_u7406_u548C_u9010_u8DF3_u9996_u90E8"><a href="#u4EE3_u7406_u548C_u9010_u8DF3_u9996_u90E8" class="headerlink" title="代理和逐跳首部"></a>代理和逐跳首部</h4><p>为避免此类代理通信问题的发生，现代的代理都绝不能转发Connection首部和所有名字出现在Connection值中的首部。因此，如果一个代理收到了一个Connection:Keep-Alive首部，是不应该转发Connection首部，或所有名为Keep-Alive首部的。<br>还有几个不能作为Connection首部值列出，也不能被代理转发或作为缓存响应使用的首部：Proxy-Authenticate, Proxy-Connection, Transfer-Encoding和Upgrade。</p>
<h3 id="u63D2_u5165Proxy-Connection"><a href="#u63D2_u5165Proxy-Connection" class="headerlink" title="插入Proxy-Connection"></a>插入Proxy-Connection</h3><p>使用Porxy-Connection来解决盲中继问题：<br>在客户端和服务器之间只有一个代理时可以用这种方案来解决问题，如果在哑代理的任意一侧还有一个聪明的代理，这个问题就会再次露头了。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.7pic01.png" alt="Proxy-Connection首部修正了单个盲中继带来的问题" title="Proxy-Connection首部修正了单个盲中继带来的问题"></p>
<p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.5.7pic02.png" alt="对有多层次代理的情况，Proxy-Connection仍然无法解决问题" title="对有多层次代理的情况，Proxy-Connection仍然无法解决问题"></p>
<h3 id="HTTP/1-1_u6301_u4E45_u8FDE_u63A5"><a href="#HTTP/1-1_u6301_u4E45_u8FDE_u63A5" class="headerlink" title="HTTP/1.1持久连接"></a>HTTP/1.1持久连接</h3><p>HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为<strong>持久连接(persistent connection)</strong>的改进型设计取代了它。持久连接的目的与keep-alive连接的目的相同，但工作机制更优些。<br>HTTP/1.1持久连接在默认情况下是激活的。除非特别指明，否则HTTP/1.1假定所有连接都是持久的。要在事务处理结束之后将连接关闭，HTTP/1.1应用程序必须向报文中显式地添加一个Connection:close首部。<br>HTTP/1.1客户端假定在收到响应后，除非响应中包含了Connection:close首部，不然HTTP/1.1连接就仍维持在打开状态。但是客户端和服务器仍然可以随时关闭空闲的连接。不发送Connection:close并不意味着服务器承诺永远将连接保持在打开状态。</p>
<h3 id="u6301_u4E45_u8FDE_u63A5_u7684_u9650_u5236__u548C_u89C4_u5219"><a href="#u6301_u4E45_u8FDE_u63A5_u7684_u9650_u5236__u548C_u89C4_u5219" class="headerlink" title="持久连接的限制 和规则"></a>持久连接的限制 和规则</h3><p>在持久连接的使用中有以下限制：</p>
<ul>
<li>发送了Connection:close请求首部之后，客户端就无法在那条连接上发送更多的请求了。</li>
<li>如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个Connection:close请求首部。</li>
<li>只有当连接上所有的报文都有正确的、自定义报文长度时–也就是说，实体主体部分的长度赵向阳和相应的Content-Length一致，或者是用分块传输编码方式编码的–连接才能持久保持。</li>
<li>HTTP/1.1的代理必须能够分别管理与客户端和服务器的持久连接–每个持久连接都只适用于一跳传输。</li>
<li>（由于较老的代理会转发Connection首部，所以）HTTP/1.1的代理服务器不应该与HTTP/1.0客户端建立持久连接，除非它们了解客户端的处理能力。</li>
<li>尽管服务器不应该试图在传输报文的过程中关闭连接，而且在关闭连接之前至少应该响应一条请求，但不管Connection首部取了什么值，HTTP/1.1设备都可以在任意时刻关闭连接。</li>
<li>HTTP/1.1应用程序必须能够从异步的关闭中恢复出来。只要不存在可能会累积起来的副作用，客户端都应该重试这条请求。</li>
<li>除非重复发起请求会产生副作用，否则如果在客户端收到整条响应之前连接关闭了，客户端就必须要重新发起请求</li>
<li>一个用户客户端对任何服务器或代理最多只能维持两条持久连接，以防服务器过载。代理可能需要更多到服务器的连接来支持并发用户的通信。所以，如果有N个用户试图访问服务器的话，代理最多要维持2N条到任意服务器或父代理的连接。</li>
</ul>
<h3 id="u7BA1_u9053_u5316_u8FDE_u63A5"><a href="#u7BA1_u9053_u5316_u8FDE_u63A5" class="headerlink" title="管道化连接"></a>管道化连接</h3><p>HTTP/1.1允许在持久连接上可选地使用<strong>请求管道</strong>。这是在keep-alive连接上的进一步性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高延时网络条件下，这样做可以降低网络的环回时间，提高性能。<br><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.6.0pic01.png" alt="4个事务（管道化连接）"><br>管道化连接的几条限制：</p>
<ul>
<li>如果HTTP客户端无法确认连接是持久的，就不应该使用管道。</li>
<li>必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。</li>
<li>HTTP客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接，并立即发出了10条请求，服务器可能在只处理了，比方说，5条请求之后关闭连接。剩下的5条请求会失败，客户端必须能够应对这些过早关闭连接的情况，重新发出这些请求。</li>
<li>HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）。总之，出错的时候 ，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法完全地重试POST这样的非幂等请求，所以出错时，就存在某些方法永远不会被执行的风险。</li>
</ul>
<h2 id="u5173_u95ED_u8FDE_u63A5_u7684_u5965_u79D8"><a href="#u5173_u95ED_u8FDE_u63A5_u7684_u5965_u79D8" class="headerlink" title="关闭连接的奥秘"></a>关闭连接的奥秘</h2><h3 id="u201C_u4EFB_u610F_u201D_u89E3_u9664_u8FDE_u63A5"><a href="#u201C_u4EFB_u610F_u201D_u89E3_u9664_u8FDE_u63A5" class="headerlink" title="“任意”解除连接"></a>“任意”解除连接</h3><p>所有HTTP客户端、服务器或代理都可以在任意时刻关闭一条TCP传输连接。通常会在一条报文结束时关闭连接，但出错的时候，也可能在首部行的中间，或其他奇怪的地方关闭连接。<br>对管道化持久连接来说，这种情形是很常见的。HTTP应用程序可以在经过任意一段时间之后，关闭持久连接。比如，在持久连接空闲一段时间之后，服务器可能会决定将其关闭。<br>服务器永远都无法确定在它关闭“空闲”连接的那一刻，在线路那一头的客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现连接错误。</p>
<h3 id="Content-Length_u53CA_u622A_u5C3E_u64CD_u4F5C"><a href="#Content-Length_u53CA_u622A_u5C3E_u64CD_u4F5C" class="headerlink" title="Content-Length及截尾操作"></a>Content-Length及截尾操作</h3><p>每条HTTP响应都应该有精确的Content-Length首部，用以描述响应主体的尺寸。一些老的HTTP服务器会省略Content-Length首部，或者包含错误的长度指示，这样就要依赖服务器发出的连接关闭来说明数据的真实末尾。<br>客户端或代理收到一条随连接关闭而结束的HTTP响应，且实际传输的实体长度与Content-Length并不匹配（或没有Content-Length）时，接收端就应该质疑长度的正确性。<br>如果接收端是个缓存代理，接收端就不应该缓存这条响应（以降低今后将潜在的错误报文混合起来的可能）。代理应该将有问题的报文原封不动地转发出去，而不应该试图去“校正”Content-Length，以维护语义的透明性。</p>
<h3 id="u8FDE_u63A5_u5173_u95ED_u5BB9_u9650_u3001_u91CD_u8BD5_u4EE5_u53CA_u5E42_u7B49_u6027"><a href="#u8FDE_u63A5_u5173_u95ED_u5BB9_u9650_u3001_u91CD_u8BD5_u4EE5_u53CA_u5E42_u7B49_u6027" class="headerlink" title="连接关闭容限、重试以及幂等性"></a>连接关闭容限、重试以及幂等性</h3><p>即使在非错误情况下，连接也可以在任意时刻关闭。HTTP应用程序要做好正确处理非预期关闭的准备。<br>如果一个事务，不管是执行一次还是很多次，得到的结果都相同，这个事务就是<strong>幂等</strong>的。实现者们可以认为GET,HEAD,PUT,DELETE,TRACE,OPTIONS方法都共享这一特性。客户端不应该以管道化方式传送非幂等请求（比如POST）。否则，传输连接的过早终止就会造成一些不确定的后果。要发送一条非幂等请求，就需要等待来自前一条请求的的响应状态。<br>用户Agent代理可能会让操作员来选择是否对请求进行重试，但一定不能自动重试非幂等方法或序列。</p>
<h3 id="u6B63_u5E38_u5173_u95ED_u8FDE_u63A5"><a href="#u6B63_u5E38_u5173_u95ED_u8FDE_u63A5" class="headerlink" title="正常关闭连接"></a>正常关闭连接</h3><p><img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.7.4pic01.png" alt="TCP连接是双向的"><br>TCP连接是双向的。</p>
<ol>
<li>完全关闭与半关闭<br> 应用程序可以关闭TCP输入和输出信道中的任意一个，或者将两个都关闭了。<br> <strong>完全关闭</strong>：套接字调用close()会将TCP连接的输入和输出信道都关闭了。<br> <strong>半关闭</strong>：套接字调用shutdown()单独关闭输入或输出信道。<br> <img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.7.4pic02.png" alt="完全关闭和半关闭"></li>
<li>TCP关闭及重置错误<br> 简单的HTTP应用程序可以只使用完全关闭，但当应用程序开始与很多其他类型的HTTP客户端、服务器和代理进行对话且开始使用管道化持久连接时，使用半关闭来防止对等实体收到非预期的写入错误就变得很重要了。<br> 关闭连接的输出信道总是很安全的。连接另一端的对等实体会在从缓冲区中读出所有数据之后收到一条通知，说明流结束了，这样它就知道你将连接关闭了。<br> 关闭连接的输入信道比较危险，除非你知道另一端不打算再发送其他数据了。如果另一端向你已关闭的输入信道发送数据，操作系统就会向另一端的机器回送一条TCP“连接被对端重置”的报文，大部分系统都会将这种错误作为很严重的错误来处理，删除对端还未读取的所有缓存数据。<br> <img src="http://7xp9un.com1.z0.glb.clouddn.com/blog%2FhttpChapter4%2F4.7.4pic03.png" alt="将数据传送到已关闭连接时会产生“连接被对端重置”错误"></li>
<li>正常关闭<br> HTTP规范建议，当客户端或服务器突然要关闭一条连接时，应该“正常地关闭传输连接”。<br> 实现正常关闭的应用程序首先应该关闭它们的输出信道，然后等待连接另一端的对等实体关闭它的输出信道，当两端都告诉对方它们不会再发送任何数据（比如关闭输出信道）之后，连接就会被完全关闭，而不会有重置的危险。<br> 无法确保对等实体会实现半关闭，或对其进行检查。因此想要正常关闭连接的应用程序应该先半关闭其输出信道，然后周期性地检查其输入信道的状态（查找数据，或流的末尾）。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接，以节省资源。</li>
</ol>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/HTTP/" rel="tag">#HTTP</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/05/http-the-definitive-guide-notes03/" rel="next" title="HTTP权威指南 笔记三">
                <i class="fa fa-chevron-left"></i> HTTP权威指南 笔记三
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/04/06/http-the-definitive-guide-notes04/"
           data-title="HTTP权威指南 笔记四" data-url="http://bettersth.xyz/2016/04/06/http-the-definitive-guide-notes04/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xp9un.com1.z0.glb.clouddn.com/blog/avatar.jpg"
               alt="sth" />
          <p class="site-author-name" itemprop="name">sth</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#u8FDE_u63A5_u7BA1_u7406"><span class="nav-number">1.</span> <span class="nav-text">连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP_u8FDE_u63A5"><span class="nav-number">1.1.</span> <span class="nav-text">TCP连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP_u53EF_u9760_u6570_u636E_u7BA1_u9053"><span class="nav-number">1.1.1.</span> <span class="nav-text">TCP可靠数据管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP_u6D41_u662F_u5206_u6BB5_u7684_u3001_u7531IP_u5206_u7EC4_u4F20_u9001"><span class="nav-number">1.1.2.</span> <span class="nav-text">TCP流是分段的、由IP分组传送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4FDD_u6301TCP_u8FDE_u63A5_u7684_u6B63_u786E_u8FD0_u884C"><span class="nav-number">1.1.3.</span> <span class="nav-text">保持TCP连接的正确运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u7528TCP_u5957_u63A5_u5B57_u7F16_u7A0B"><span class="nav-number">1.1.4.</span> <span class="nav-text">用TCP套接字编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u5BF9TCP_u6027_u80FD_u7684_u8003_u8651"><span class="nav-number">1.2.</span> <span class="nav-text">对TCP性能的考虑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP_u4E8B_u52A1_u7684_u65F6_u5EF6"><span class="nav-number">1.2.1.</span> <span class="nav-text">HTTP事务的时延</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u6027_u80FD_u805A_u7126_u533A_u57DF"><span class="nav-number">1.2.2.</span> <span class="nav-text">性能聚焦区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP_u8FDE_u63A5_u7684_u63E1_u624B_u65F6_u5EF6"><span class="nav-number">1.2.3.</span> <span class="nav-text">TCP连接的握手时延</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u5EF6_u8FDF_u786E_u8BA4"><span class="nav-number">1.2.4.</span> <span class="nav-text">延迟确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP_u6162_u542F_u52A8"><span class="nav-number">1.2.5.</span> <span class="nav-text">TCP慢启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nagle_u7B97_u6CD5_u4E0ETCP_NODELAY"><span class="nav-number">1.2.6.</span> <span class="nav-text">Nagle算法与TCP_NODELAY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TIME_WAIT_u7D2F_u79EF_u4E0E_u7AEF_u53E3_u8017_u5C3D"><span class="nav-number">1.2.7.</span> <span class="nav-text">TIME_WAIT累积与端口耗尽</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP_u8FDE_u63A5_u7684_u5904_u7406"><span class="nav-number">1.3.</span> <span class="nav-text">HTTP连接的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u5E38_u88AB_u8BEF_u89E3_u7684Connection_u9996_u90E8"><span class="nav-number">1.3.1.</span> <span class="nav-text">常被误解的Connection首部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4E32_u884C_u4E8B_u52A1_u5904_u7406_u65F6_u5EF6"><span class="nav-number">1.3.2.</span> <span class="nav-text">串行事务处理时延</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u5E76_u884C_u8FDE_u63A5"><span class="nav-number">1.4.</span> <span class="nav-text">并行连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u5E76_u884C_u8FDE_u63A5_u53EF_u80FD_u4F1A_u63D0_u9AD8_u9875_u9762_u7684_u52A0_u8F7D_u901F_u5EA6"><span class="nav-number">1.4.1.</span> <span class="nav-text">并行连接可能会提高页面的加载速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u5E76_u884C_u8FDE_u63A5_u4E0D_u4E00_u5B9A_u66F4_u5FEB"><span class="nav-number">1.4.2.</span> <span class="nav-text">并行连接不一定更快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u5E76_u884C_u8FDE_u63A5_u53EF_u80FD_u8BA9_u4EBA_u201C_u611F_u89C9_u201D_u66F4_u5FEB_u4E00_u4E9B"><span class="nav-number">1.4.3.</span> <span class="nav-text">并行连接可能让人“感觉”更快一些</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u6301_u4E45_u8FDE_u63A5"><span class="nav-number">1.5.</span> <span class="nav-text">持久连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u6301_u4E45_u4EE5_u53CA_u5E76_u884C_u8FDE_u63A5"><span class="nav-number">1.5.1.</span> <span class="nav-text">持久以及并行连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP/1-0+keep-alive_u8FDE_u63A5"><span class="nav-number">1.5.2.</span> <span class="nav-text">HTTP/1.0+keep-alive连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Keep-Alive_u64CD_u4F5C"><span class="nav-number">1.5.3.</span> <span class="nav-text">Keep-Alive操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Keep-Alive_u9009_u9879"><span class="nav-number">1.5.4.</span> <span class="nav-text">Keep-Alive选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Keep-Alive_u8FDE_u63A5_u7684_u9650_u5236_u548C_u89C4_u5219"><span class="nav-number">1.5.5.</span> <span class="nav-text">Keep-Alive连接的限制和规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Keep-Alive_u548C_u54D1_u4EE3_u7406"><span class="nav-number">1.5.6.</span> <span class="nav-text">Keep-Alive和哑代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Connection_u9996_u90E8_u548C_u76F2_u4E2D_u7EE7"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">Connection首部和盲中继</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u4EE3_u7406_u548C_u9010_u8DF3_u9996_u90E8"><span class="nav-number">1.5.6.2.</span> <span class="nav-text">代理和逐跳首部</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u63D2_u5165Proxy-Connection"><span class="nav-number">1.5.7.</span> <span class="nav-text">插入Proxy-Connection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP/1-1_u6301_u4E45_u8FDE_u63A5"><span class="nav-number">1.5.8.</span> <span class="nav-text">HTTP/1.1持久连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u6301_u4E45_u8FDE_u63A5_u7684_u9650_u5236__u548C_u89C4_u5219"><span class="nav-number">1.5.9.</span> <span class="nav-text">持久连接的限制 和规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u7BA1_u9053_u5316_u8FDE_u63A5"><span class="nav-number">1.5.10.</span> <span class="nav-text">管道化连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u5173_u95ED_u8FDE_u63A5_u7684_u5965_u79D8"><span class="nav-number">1.6.</span> <span class="nav-text">关闭连接的奥秘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u201C_u4EFB_u610F_u201D_u89E3_u9664_u8FDE_u63A5"><span class="nav-number">1.6.1.</span> <span class="nav-text">“任意”解除连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Content-Length_u53CA_u622A_u5C3E_u64CD_u4F5C"><span class="nav-number">1.6.2.</span> <span class="nav-text">Content-Length及截尾操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u8FDE_u63A5_u5173_u95ED_u5BB9_u9650_u3001_u91CD_u8BD5_u4EE5_u53CA_u5E42_u7B49_u6027"><span class="nav-number">1.6.3.</span> <span class="nav-text">连接关闭容限、重试以及幂等性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u6B63_u5E38_u5173_u95ED_u8FDE_u63A5"><span class="nav-number">1.6.4.</span> <span class="nav-text">正常关闭连接</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sth</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"bettersth"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  

  
  


</body>
</html>
